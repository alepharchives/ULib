#!/bin/bash

set_ENV() {

	# global var
	BASE_NAME=$(basename $1 .sh)

	if [ -z "$HTTP_ACCEPT_LANGUAGE" -o ! -d ../form/$HTTP_ACCEPT_LANGUAGE ]; then
		HTTP_ACCEPT_LANGUAGE=en
	fi

	FORM_FILE_DIR=../form/$HTTP_ACCEPT_LANGUAGE

	# environment
 	source /srv/wifi-portal/etc/environment.conf

	# we can do services... ?
	if [ -x $PIAZZE_FI/ANOMALIA ]; then
		ANOMALIA_page
	fi

# --------------------------------
#  session cookie (no NAT)
# --------------------------------
	SESSION_ID=$REMOTE_ADDR
# --------------------------------
#  session cookie (with NAT)
# --------------------------------
#	if [ -n "$HTTP_COOKIE" ]; then
#		SESSION_ID=$HTTP_COOKIE
#	else
#     SET_COOKIE=SESS_$$
#		SESSION_ID=$SET_COOKIE
#	fi
# --------------------------------

	# ---------------------------------------------------------------------
	# NB: se cambia qualcosa qui, bisogna cambiarlo anche nel .env di admin
	# ---------------------------------------------------------------------
	DIR_REQ=../request
	DIR_CTX=../login
	DIR_CNT=../counter
	DIR_REG=../registration
	DIR_STAT=../stat

	FILE_LOG=/var/log/LOG
	# ---------------------------------------------------------------------

	EXIT_VALUE=0
	BACK_TAG="<a class=\"back\" href=\"#\" onclick=\"history.go(-1);return false;\">INDIETRO</a>"
	TELEFONO="055-055"
	MSG_ANOMALIA="Errore di autenticazione (anomalia %s). Si prega di riprovare, se il problema persiste contattare: $TELEFONO"
	LDAP_USER_PARAM="-x -D $WIAUTH_USER_LDAP_BINDDN -w $WIAUTH_USER_LDAP_PWD -h $WIAUTH_USER_LDAP_SERVER -p $WIAUTH_USER_LDAP_PORT"
	LDAP_CARD_PARAM="-x -D $WIAUTH_CARD_LDAP_BINDDN -w $WIAUTH_CARD_LDAP_PWD -h $WIAUTH_CARD_LDAP_SERVER -p $WIAUTH_CARD_LDAP_PORT"

	if [ -n "$HTTP_HEADER_HOST" ]; then
		SERVER=$HTTP_HEADER_HOST
	else
		SERVER=$SERVER_ADDR
	fi

	export OUTPUT BASE_NAME FORM_FILE_DIR OP FILE_LOG DIR_CTX DIR_REQ FILE_CTX \
			 NOCAT_TIMEOUT MAC IP GATEWAY AP TMP_FORM_FILE UUID SET_COOKIE SESSION_ID CALLER_ID \
			 USER SIGNED_DATA BACK_TAG PROT SERVER UUID_TO_APPEND LDAP_USER_PARAM LDAP_CARD_PARAM EXIT_VALUE CONNECTION_CLOSE TELEFONO
}

write_OUTPUT() {

	if [ -n "$1" ]; then

		if [ -n "$CONNECTION_CLOSE" ]; then
			echo -e "Connection: close\r"
		fi

		if [ -n "$SET_COOKIE" ]; then

			# REQ: Set-Cookie: TODO[ data expire path domain secure HttpOnly ]
			# ----------------------------------------------------------------------------------------------------------------------------
			# string -- Data to put into the cookie         -- must
			# int    -- Lifetime of the cookie in HOURS     -- must (0 -> valid until browser exit)
			# string -- Path where the cookie can be used   --  opt
			# string -- Domain which can read the cookie    --  opt
			# bool   -- Secure mode                         --  opt
			# bool   -- Only allow HTTP usage               --  opt
			# ----------------------------------------------------------------------------------------------------------------------------
			# RET: Set-Cookie: ulib_sid=data&expire&HMAC-MD5(data&expire); expires=expire(GMT); path=path; domain=domain; secure; HttpOnly

			echo "Set-Cookie: TODO[ $SET_COOKIE 4320 ]" # 180 days

		fi

		echo -e "Content-Type: text/html; charset=utf8\r\n\r"
		echo -n -E "$1"

		exit $EXIT_VALUE 

	fi
}

anomalia() {

	# ---------------------------------------------
	# $1 -> exit value
	# ---------------------------------------------
	# 2 write_FILE
	# 3 append_to_FILE
	# 4 sign_data
	# 5 send_request_to_nodog (curl | uclient)
	# 6 info_notified_from_nodog (missing ctx)
	# 7 info_notified_from_nodog (RENEW)
	# 8 ask_to_LDAP
	# 9 login_request_from_PIAZZE (req without ctx)
	# ---------------------------------------------

	EXIT_VALUE=$1

	MSG=`printf "$MSG_ANOMALIA" 00$1`

	case "$1" in
	9)
		logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: login_request_from_PIAZZE() failure (anomalia 009)"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"
	;;
	8)
		logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: Servizio LDAP non disponibile (anomalia 008)"

		if [ -n "$ADMIN_CONTEXT" ]; then
			MSG=`printf "Servizio LDAP non disponibile (anomalia %s). Contattare l'assistenza." 00$1`
		else
			BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		fi

		message_page "Servizio LDAP non disponibile" "$MSG"
	;;
	7 | 6)
		MSG=`printf "$BASE_NAME: info_notified_from_nodog() failure (anomalia %s)" 00$1 file_ctx=\"$FILE_CTX\"`

		logger -p $LOCAL_SYSLOG_SELECTOR "$MSG"

		ask_nodog_to_logout_user

		return
	;;
	5)
		logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: send_request_to_nodog() failure (anomalia 005) gateway=$GATEWAY"

		return
	;;
	4)
		logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: sign_data() failure (anomalia 004)"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"
	;;
	*)
		chmod 777 $PIAZZE_FI/ANOMALIA

		ANOMALIA_page
	;;
	esac

	exit $1
}

write_FILE() {

	# $1 -> data
	# $2 -> filename
	# $3 -> option

	echo $3 "$1" > $2

	if [ $? -ne 0 ]; then
		anomalia 2
	fi
}

append_to_FILE() {

	# $1 -> data
	# $2 -> filename

	echo "$1" >> $2

	if [ $? -ne 0 ]; then
		anomalia 3
	fi
}

_date() { date '+%Y/%m/%d %H:%M:%S' ; }

write_to_LOG() {

	# $1 -> uid
	# $2 -> ap
	# $3 -> ip
	# $4 -> mac
	# $5 -> timeout
	# $6 -> traffic

	RIGA="`_date` op: $OP, uid: $1, ap: $2, ip: $3, mac: $4, timeout: $5, traffic: $6"

	append_to_FILE "$RIGA" $FILE_LOG

	sync

	logger -p $REMOTE_SYSLOG_SELECTOR "$RIGA"
}

send_request_to_nodog() {

	# $1 -> url
	# $2 -> filename to save output
	# $3 -> option

	# we send request to nodog...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	#UTRACE="0 10M 0"
	#UOBJDUMP="0 100k 10"
	#USIMERR="error.sim"
	export UTRACE UOBJDUMP USIMERR

	OUTPUT=`$CLIENT_HTTP $3 "$1" 2>>/tmp/CLIENT_HTTP.err`

	if [ $? -ne 0 ]; then
		anomalia 5
	fi

	if [ -n "$2" -a -n "$OUTPUT" ]; then

		write_FILE "$OUTPUT" $2

		unset OUTPUT

	fi
}

ask_to_LDAP() {

#	set -x

	# $1 -> cmd
	# $2 -> param
	# $3 -> option
	# $4 -> filter_option

	TMPFILE=/tmp/ask_to_LDAP.$$

	if [ "$1" = ldapsearch ]; then
		OUTPUT=`$1 $2 "$3" $4 2>$TMPFILE`
	else
		$1 $2 <<END >$TMPFILE 2>&1
$3
END
	fi

	EXIT_VALUE=$?

 	if [ $EXIT_VALUE -eq 0 ]; then

 		rm -f $TMPFILE

 	elif [ -s $TMPFILE ]; then

 		grep '(-1)' < $TMPFILE # Can't contact LDAP server (-1)

 		if [ $? -eq 0 ]; then
			anomalia 8
 		fi

 	fi

#	set +x
}

print_page() {

	OUTPUT=`cat $FORM_FILE_DIR/$BASE_NAME.tmpl 2>/dev/null`

	if [ $# -ne 0 ]; then
		OUTPUT=`printf "$OUTPUT" "$@" 2>/dev/null`
	fi
}

logout_page() {

	print_page
}

logout_popup() {

	# $1 -> uid
	# $2 -> gateway

	CONNECTION_CLOSE=1

	BASE_NAME=logout_popup

	print_page "$1"
}

message_page() {

	BASE_NAME=message_page

	print_page "$@" "$BACK_TAG"

	write_OUTPUT "$OUTPUT"
}

ANOMALIA_page() {

	BASE_NAME=ANOMALIA_page

	print_page "$@"

	write_OUTPUT "$OUTPUT"
}

save_connection_request() {

	# $1 -> ap
	# $2 -> gateway
	# $3 -> mac
	# $4 -> ip
	# $5 -> redirect
	# $6 -> timeout
	# $7 -> token

	# ---------------------------------------------------------------------------------
	# SAVE REQUEST CONTEXT DATA ON FILE (AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID)
	# ---------------------------------------------------------------------------------
	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	write_FILE "$1 $2 $3 $4 $5 $6 $7" $DIR_REQ/$SESSION_ID.req "-n"
	# ---------------------------------------------------------------------------------
}

save_connection_context() {

	# $1 -> ap
	# $2 -> uid
	# $3 -> gateway
	# $4 -> mac
	# $5 -> ip

	# --------------------------------------------------------------------
	# SAVE CONNECTION CONTEXT DATA ON FILE (AP UUID GATEWAY MAC IP)
	# --------------------------------------------------------------------
	FILE_CTX=$DIR_CTX/$2.ctx

	write_FILE "$1 $2 $3 $4 $5" $FILE_CTX
	# --------------------------------------------------------------------
}

get_user_context_connection() {

	# $1 -> uid

	if [ $# -eq 1 ]; then
		FILE_CTX=$DIR_CTX/$1.ctx
	else
		FILE_CTX=`grep -l $REMOTE_ADDR $DIR_CTX/*.ctx 2>/dev/null`
	fi

	# data connection context saved on file
	# -------------------------------------
	# ap uid gateway mac ip

	if [ -n "$FILE_CTX" -a -s "$FILE_CTX" ]; then
		read AP UUID GATEWAY MAC IP < $FILE_CTX
	else
		unset FILE_CTX AP UUID GATEWAY MAC IP
	fi
}

check_for_user_already_connected() {

# 	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> gateway
	# $4 -> ap
	# $5 -> uid

	get_user_context_connection $5

	if [ -n "$FILE_CTX" ]; then

		if [ "$MAC"		 != "$1" -o \
			  "$IP"		 != "$2" -o \
			  "$GATEWAY" != "$3" -o \
			  "$AP"		 != "$4" ]; then

			OP=RENEW

		fi

	fi

# 	set +x
}

user_welcome() {

#	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap

	if [ $# -eq 7 -a "$REQUEST_URI" = "/" ]; then # come from nocat
		save_connection_request $7 $4 $1 $2 $3 $5 $6
	fi

	ENABLE_BUTTON=a
	DISABLE_BUTTON=del

	get_user_context_connection

	if [ -n "$GATEWAY" ]; then

		# check if he is still connected...

		ask_nodog_status_user

		echo "$OUTPUT" | grep PERMIT 2>/dev/null

		if [ $? -ne 0 ]; then

			unset UUID

			rm -f $FILE_CTX # NB: FILE_CTX e' settato da get_user_context_connection()...

		fi

	fi

	if [ -n "$UUID" ]; then
		# connesso, quindi registrato...
		REGISTRATI=$DISABLE_BUTTON
		LOGIN=$DISABLE_BUTTON
		LOGOUT=$ENABLE_BUTTON
	   STATUS=$ENABLE_BUTTON
	else
		# non connesso
		REGISTRATI=$ENABLE_BUTTON
		LOGIN=$ENABLE_BUTTON
		LOGOUT=$DISABLE_BUTTON
	   STATUS=$DISABLE_BUTTON
	fi

	CONNECTION_CLOSE=1

	print_page $REGISTRATI $REGISTRATI \
				  $LOGIN		  $LOGIN \
				  $LOGOUT	  $LOGOUT \
				  $STATUS	  $STATUS

#	set +x
}

login_request_from_nocat() {

	#	$1	-> mac
	#	$2 -> ip
	#	$3	-> redirect
	#	$4	-> gateway
	#	$5	-> timeout
	#	$6	-> token
	#	$7	-> ap

	user_has_valid_MAC "$@"

	if [ -n "$SSL_CLIENT_CERT_SERIAL" ]; then
		user_has_valid_cert "$@"
	fi

	print_page "$@"
}

login_with_problem() {

	BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"

	message_page "Login error" "Errore di autenticazione. Si prega di riprovare, se il problema persiste contattare: $TELEFONO"
}

login_request_from_PIAZZE() {

#	set -x

	# $1 -> realm
	# $2 -> uid
	# $3 -> password
	# $4 -> bottone

   BASE_NAME=login

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		login_with_problem
	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT NOCAT_TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -n "$UUID" ]; then

		FILE_CTX=$DIR_CTX/$UUID.ctx

		if [ ! -s $FILE_CTX ]; then
			anomalia 9
		fi

		BACK_TAG=""

		message_page "Login error" "Sei gia' loggato!"

	fi

	UUID_TO_APPEND=1

	if [ "$1" = "paas" ]; then
		auth_check_card_paas "$MAC" $IP "$REDIRECT" $GATEWAY $NOCAT_TIMEOUT "$TOKEN" $AP "$@"
	else
		auth_check_card		"$MAC" $IP "$REDIRECT" $GATEWAY $NOCAT_TIMEOUT "$TOKEN" $AP "$@"
	fi

#	set +x
}

post_login() {

	# $1 -> uid
	# $2 -> gateway
	# $3 -> redirect
	# $4 -> ap
	# $5 -> ip
	# $6 -> mac
	# $7 -> timeout
	# $8 -> traffic

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		login_with_problem
	fi

	FILE_CTX=$DIR_CTX/$1.ctx

	if [ -s $FILE_CTX ]; then

		BACK_TAG=""

		message_page "PostLogin error" "Sei gia' loggato!"

	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT NOCAT_TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -z "$UUID" ]; then
		login_with_problem
	fi

	OP=LOGIN

	write_to_LOG "$1" "$4" "$5" "$6" "$7" "$8"

	# --------------------------------------------------------------------
	# SAVE CONNECTION CONTEXT DATA ON FILE (AP UUID GATEWAY MAC IP)
	# --------------------------------------------------------------------
	save_connection_context $4 $1 $2 $6 $5
	# --------------------------------------------------------------------

	CONNECTION_CLOSE=1

	print_page "$1" "$2" "$3" "$1" "$3" "$3"
}

user_has_valid_MAC() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap

	# List of allowed MAC

	FILE=$DIR_CTX/.MAC_WHITE_LIST

	if [ -s $FILE ]; then

		while read MAC
		do

			if [ "$MAC" = "$1" ]; then

				OP=MAC_AUTH

				send_ticket "$@" "$MAC" 

			fi

		done < $FILE

	fi
}

user_has_valid_cert() {

	if [ "$BASE_NAME" = "undax_login" ]; then

		WIAUTH_USER_LDAP_SERVER=localhost

		LDAP_USER_PARAM="-x -D $WIAUTH_USER_LDAP_BINDDN -w $WIAUTH_USER_LDAP_PWD -h $WIAUTH_USER_LDAP_SERVER -p $WIAUTH_USER_LDAP_PORT"

	fi

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_USER_BASEDN $LDAP_USER_PARAM" \
			"(&(objectClass=waUser)(&(waIssuer=$SSL_CLIENT_I_DN)(waSerial=$SSL_CLIENT_CERT_SERIAL)(waActive=TRUE)))"

	if [ -n "$OUTPUT" ]; then

		# NoCat is calling for auth, redirect back to the gateway appending a signed GPG ticket that will signal NoCat to unlock the firewall...

		USER=`echo "$OUTPUT" | grep 'waUid: ' | cut -f2 -d' ' 2>/dev/null`

		OP=CERT_AUTH

		send_ticket "$@" "$USER"

	fi
}

ask_nodog_status_user() {

	# we request the status of the indicated user...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	send_request_to_nodog "http://$GATEWAY/status?ip=$REMOTE_ADDR"
}

ask_nodog_to_logout_user() {

	# we request to logout this user with the old ip from the associated gateway...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	SIGNED_DATA="ip=$IP&mac=$MAC"

	sign_data

	send_request_to_nodog "http://$GATEWAY/logout?$SIGNED_DATA"
}

ask_nodog_to_check_for_users_info() {

#	set -x

	# we request nodog to check for users logout or disconnect...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	FILE_TMP=/tmp/nodog.check.$$

	send_request_to_nodog "http://$GATEWAY/check" $FILE_TMP "-i"

	if [ -s $FILE_TMP ]; then

		read HTTP_VERSION HTTP_STATUS HTTP_DESCR < $FILE_TMP

		if [ "$HTTP_STATUS" = "204" ]; then # 204 - HTTP_NO_CONTENT

			sleep 9

			ask_nodog_to_check_for_users_info

		fi

		rm -f $FILE_TMP
	fi

#	set +x
}

get_status_ap() {

	# $1 -> gateway
	# $2 -> ap

	# we request the status of the indicated gateway...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	GATEWAY=$1

	send_request_to_nodog "http://$GATEWAY/status" $DIR_STAT/$2.html

	echo -e "Location: /wi-auth/stat/$2.html\r\n\r"

	exit 0
}

sign_data() {

	SIGNED_DATA_FILE=/tmp/signed.$$

 	GPG_CMD="gpg --homedir=$GPG_HOME/gpg --keyring=$GPG_HOME/gpg/trustdb.gpg -o $SIGNED_DATA_FILE"

	$GPG_CMD --sign --armor --no-tty <<END 2>/dev/null
$SIGNED_DATA
END

	if [ ! -s $SIGNED_DATA_FILE ]; then
		anomalia 4
	fi

	SIGNED_DATA=`tail -n +4 $SIGNED_DATA_FILE | head -n -1 | perl -e "use URI::Escape; print uri_escape(join('',<>));" 2>/dev/null`

	rm -f $SIGNED_DATA_FILE
}

send_ticket() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap
	# $8 -> uid

	# -------------------------------------------------------------
	# CHECK FOR CHANGE OF CONNECTION CONTEXT FOR SAME USER ID
	# -------------------------------------------------------------
	check_for_user_already_connected "$1" "$2" "$4" "$7" "$8"

	if [ "$OP" = "RENEW" ]; then
		ask_nodog_to_logout_user
	fi

	FILE_CNT=$DIR_CNT/$8
	# --------------------------------------------------------------------
	# WE CHECK FOR THE TIME REMAIN FOR CONNECTION (SECS) SAVED ON FILE
	# --------------------------------------------------------------------
	REMAIN=$FILE_CNT.timeout

	if [ ! -s $REMAIN ]; then
		NOCAT_TIMEOUT=$MAX_TIME
		# ---------------------------------------------------------
		# we save the time remain for connection (secs) on file
		# ---------------------------------------------------------
		write_FILE $NOCAT_TIMEOUT $FILE_CNT.timeout
		# ---------------------------------------------------------
	else
		read NOCAT_TIMEOUT < $REMAIN

		if [ $NOCAT_TIMEOUT -eq 0 ]; then
			message_page "Tempo consumato" "Hai consumato il tempo disponibile del servizio!"
		fi
	fi
	# --------------------------------------------------------------------

	# --------------------------------------------------------------------
	# WE CHECK FOR THE TRAFFIC REMAIN FOR CONNECTION (BYTES) SAVED ON FILE
	# --------------------------------------------------------------------
	REMAIN=$FILE_CNT.traffic

	if [ ! -s $REMAIN ]; then
		TRAFFIC=$MAX_TRAFFIC
		# ---------------------------------------------------------
		# we save the remain traffic for connection (bytes) on file
		# ---------------------------------------------------------
		write_FILE $TRAFFIC $FILE_CNT.traffic
		# ---------------------------------------------------------
	else
		read TRAFFIC < $REMAIN

		if [ $TRAFFIC -eq 0 ]; then
			message_page "Traffico consumato" "Hai consumato il traffico disponibile del servizio!"
		fi
	fi

 	     ap_URL_ENCODE=`echo -n $7 | perl -e "use URI::Escape; print uri_escape(join('',<>));" 2>/dev/null`
 	    mac_URL_ENCODE=`echo -n $1 | perl -e "use URI::Escape; print uri_escape(join('',<>));" 2>/dev/null`
 	gateway_URL_ENCODE=`echo -n $4 | perl -e "use URI::Escape; print uri_escape(join('',<>));" 2>/dev/null`

#	redirect_URL_ENCODE=`echo -n $3					  | perl -e "use URI::Escape; print uri_escape(join('',<>));" 2>/dev/null`
 	redirect_URL_ENCODE=`echo -n $REDIRECT_DEFAULT | perl -e "use URI::Escape; print uri_escape(join('',<>));" 2>/dev/null`

	# la prima linea deve essere vuota... (vedi conf.c:36  for ( i = 1; lines[i] != NULL; i++ ) ....)

	SIGNED_DATA="

Action   Permit
Mode	   Login
Redirect	$PROT://$SERVER/postlogin?uid=$8&gateway=$gateway_URL_ENCODE&redirect=$redirect_URL_ENCODE&ap=$ap_URL_ENCODE&ip=$2&mac=$mac_URL_ENCODE&timeout=$NOCAT_TIMEOUT&traffic=$TRAFFIC
Mac		$1
Timeout	$NOCAT_TIMEOUT
Traffic	$TRAFFIC
Token		$6
User		$8"

	sign_data

	write_to_LOG "$8" "$7" "$2" "$1" "$NOCAT_TIMEOUT" "$TRAFFIC"

	if [ -n "$UUID_TO_APPEND" ]; then
		append_to_FILE " $8" $REQ_FILE # si aggiunge UUID alla request...
	fi

	echo -e "Location: http://$4/?ticket=$SIGNED_DATA\r\n\r"

	exit 0
}

get_timeout_secs() {

	DSTART=`printf "%4s-%2s-%2s %2s:%2s:%2s" ${1:0:4} ${1:4:2} ${1:6:2} ${1:8:2} ${1:10:2} ${1:12:2} 2>/dev/null`
	  DEND=`printf "%4s-%2s-%2s %2s:%2s:%2s" ${2:0:4} ${2:4:2} ${2:6:2} ${2:8:2} ${2:10:2} ${2:12:2} 2>/dev/null`

	START=`date --date="$DSTART" +%s 2>/dev/null`
	  END=`date --date="$DEND"   +%s 2>/dev/null`

	let "NOCAT_TIMEOUT = $END - $START"
}

auth_check_card_paas() {

	# $1	-> mac
	# $2  -> ip
	# $3	-> redirect
	# $4	-> gateway
	# $5	-> timeout
	# $6	-> token
	# $7	-> ap
	# $8	-> domain (es: 10_piazze, paas)
	# $9	-> uid
	# $10	-> pass
	# $11 -> button

	# es: 00:15:58:0c:9e:26 10.30.1.102 http://ap1 10.30.1.112:5280 86400 10.30.1.102&1255107570&42cb373714c ap0.rs paas 3397363258 pswd Entra

# ---------------------------------------------------------------------------------
# x LEO SECCI: MODIFICA LDAPSEARCH QUI!
# ---------------------------------------------------------------------------------
#	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_USER_BASEDN $LDAP_USER_PARAM" "waUid=$9"
# ---------------------------------------------------------------------------------

	if [ -z "$OUTPUT" ]; then
		message_page "Errore" "Errore Autorizzazione dominio PASS"
	else
		OP=AUTH_PAAS

		send_ticket "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8"
	fi
}

auth_check_card() {

	# $1	-> mac
	# $2  -> ip
	# $3	-> redirect
	# $4	-> gateway
	# $5	-> timeout
	# $6	-> token
	# $7	-> ap
	# $8	-> domain (es: 10_piazze, paas)
	# $9	-> uid
	# $10	-> pass
	# $11 -> button

	# Ex: 00:15:58:0c:9e:26 10.30.1.102 http://ap1 10.30.1.112:5280 86400 10.30.1.102&1255107570&42cb373714c ap0.rs paas 3397363258 pswd Entra

	OP=PASS_AUTH

	# ---------------------------------------------------
	# TEST (bypass LDAP)
	# ---------------------------------------------------
	# send_ticket "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$9"
	# ---------------------------------------------------

#	set -x

	if [ -z "$9" -o -z "${10}" ]; then
		message_page "Impostare utente e password" "Impostare utente e password"
	fi

	# Check 1: Registration required

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_USER_BASEDN $LDAP_USER_PARAM" "waUid=$9"

	if [ -z "$OUTPUT" ]; then
		message_page "Registrazione obbligatoria" "Per utilizzare il servizio e' richiesta la registrazione"
	fi

	# Check 2: Activation required

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" "waUsedBy=$9"

	if [ -z "$OUTPUT" ]; then
		message_page "Attivazione non effettuata" "Per utilizzare il servizio e' richiesta l'attivazione"
	fi

	# Check 3: Wrong user and/or password

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" "(&(waLogin=$9)(waPassword=${10}))"

	if [ -z "$OUTPUT" ]; then
		message_page "Password errata" "La password e' errata!"
	fi

	# Check 4: Expired registration

	GEN_TIME=`date +%Y%m%d%H%M%SZ` # GeneralizedTime YYYYmmddHH[MM[SS]][(./,)d...](Z|(+/-)HH[MM])

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" \
			"(&(objectClass=waCard)(&(waLogin=$9)(waPassword=${10})(waRevoked=FALSE)(|(!(waNotAfter=*))(waNotAfter>=$GEN_TIME))))"

	if [ -z "$OUTPUT" ]; then
		message_page "Registrazione scaduta" "La tua registrazione e' scaduta!"
	fi

	USER=`	  echo "$OUTPUT" | grep 'waUsedBy: '	| cut -f2 -d' ' 2>/dev/null`
	NOT_AFTER=`echo "$OUTPUT" | grep 'waNotAfter: ' | cut -f2 -d' ' 2>/dev/null`

	if [ -n "$NOT_AFTER" ]; then
		get_timeout_secs "$GEN_TIME" "$NOT_AFTER"
	else

		OP=FIRST_PASS_AUTH

		# Update card with a new generated waNotAfter

		DN=`		  echo "$OUTPUT" | grep 'dn: '			| cut -f2 -d' ' 2>/dev/null`
		VALIDITY=` echo "$OUTPUT" | grep 'waValidity: ' | cut -f2 -d' ' 2>/dev/null`

		let "NOCAT_TIMEOUT = $VALIDITY * 86400"

		NOT_AFTER=`date --date="+$VALIDITY days" +%Y%m%d%H%M%SZ 2>/dev/null`

		ask_to_LDAP ldapmodify "-c $LDAP_CARD_PARAM" "
dn: $DN
changetype: modify
add: waNotAfter
waNotAfter: $NOT_AFTER
"

	fi

	# redirect back to the gateway appending a signed GPG ticket that will signal NoCat to unlock the firewall...

	send_ticket "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$USER"
}

load_value_session() {

	if [ -s $TMP_FORM_FILE ]; then

		i=1
		while read LINE
		do
			eval v$i=\"$LINE\"

			let "i = i + 1"
		done < $TMP_FORM_FILE

	fi
}

save_value_session() {

	cat <<END >$TMP_FORM_FILE
$1
$2
$3
$4
$5
$6
$7
$8
$9
${10}
${11}
${12}
${13}
${14}
${15}
${16}
${17}
END
#${18}
#${19}
#${20}
#${21}
#${22}
#${23}
#${24}
}

view_form_registrazione() {

	# eventuali dati pre form input

	TMP_FORM_FILE=/tmp/$BASE_NAME.prev

	load_value_session

	# --------------------------------------
	# value to skip: (input type select)
	# --------------------------------------
	# "dati_utente_sesso					= $v5"
	# "dati_utente_tipo_di_documento = $v11"
	# "cellulare_prefisso			   = $v15"
	# --------------------------------------

	# nome				 = "$v1"
	# cognome			 = "$v2"
	# nato a				 = "$v3"
	# data di nascita  = "$v4"
	# codice fiscale	 = "$v6"
	# indirizzo			 = "$v7"
	# comune				 = "$v8"
	# provincia			 = "$v9"
	# cap					 = "${v10}"
	# numero documento = "${v12}"
	# rilasciato da	 = "${v13}"
	# rilasciato il	 = "${v14}"
	# cellulare			 = "${v16}"

	print_page $BASE_NAME \
			"$v1" \
			"$v2" \
			"$v3" \
			"$v4" \
			"$v6" \
			"$v7" \
			"$v8" \
			"$v9" \
			"${v10}" \
			"${v12}" \
			"${v13}" \
			"${v14}" \
			"${v16}" \
			/wi-auth/form/$HTTP_ACCEPT_LANGUAGE
}

polling_attivazione() {

#	set -x

	# $1 WA_CELL

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" "waUsedBy=$1" waPassword

	WA_PASSWORD=`echo "$OUTPUT" | grep waPassword: | cut -d':' -f2 2>/dev/null`

	if [ -n "$WA_PASSWORD" ]; then

		CREDENTIALS_TAG="<p class=\"bigger\">Utente: $1</p><p class=\"bigger\">Password: $WA_PASSWORD</p>"
		TITLE="LE TUE CREDENZIALI SONO:"
		REFRESH_TAG=""

		INFO="
		<p>Ti suggeriamo di prendere nota: </p>
		<ul>
		<li>
		delle credenziali che ti serviranno ogni volta che vorrai accedere al servizio
		</li>
		<li>
		della pagina di uscita (logout), magari inserendola tra i tuoi segnalibri (bookmarks). Se utilizzerai questa pagina, quando hai finito di navigare, il tempo e traffico della tua navigazione, e quindi quanto ti rimane, saranno corrispondenti a quelli effettivi
		</li>
		<p class=\"bigger\">La pagina di uscita (logout): http://$SERVER/logout_page</p>
		</ul>
		<br/>
		<p class=\"bigger\">Ora puoi accedere al servizio cliccando il bottone</p>
"

		LOGIN_FORM="
<form action=\"/login_request\" method=\"post\">
<input type=\"hidden\" name=\"realm\" value=\"10_piazze\" />
<input type=\"hidden\" name=\"uid\"   value=\"$1\">
<input type=\"hidden\" name=\"pass\"  value=\"$WA_PASSWORD\">
<input type=\"image\" src=\"wi-auth/images/accedi.gif\" name=\"submit\" value=\"Entra\" />
</form>
"

		print_page  "$REFRESH_TAG" "$TITLE" "$CREDENTIALS_TAG" "$INFO" "$LOGIN_FORM"

	else

		CREDENTIALS_TAG="<p class=\"bigger\">&nbsp;</p><p class=\"bigger\">&nbsp;</p>"
		TITLE="VERIFICA ATTIVAZIONE: ATTENDERE..."
		REFRESH_TAG="<meta http-equiv=\"refresh\" content=\"3\">"

		print_page  "$REFRESH_TAG" "$TITLE" "$CREDENTIALS_TAG" "" ""

	fi
}

request_to_logout_from_user() {

	# nocat data saved on file
	# ------------------------
	# $1 -> ap
	# $2 -> gateway
	# $3 -> mac
	# $4 -> ip
	# $5 -> redirect
	# $6 -> timeout
	# $7 -> token

	unset BACK_TAG

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		message_page "ID di sessione mancante" "Utente non connesso (session id: $SESSION_ID)"
	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT NOCAT_TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -n "$UUID" -a -s $DIR_CTX/$UUID.ctx ]; then

		ask_nodog_to_logout_user

		BASE_NAME=ringraziamenti

		print_page

	else
		message_page "Utente non connesso" "Utente non connesso"
	fi
}

info_notified_from_nodog() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> gateway
	# $4 -> ap
	# $5 -> uid
	# $6 -> logout
	# $7 -> connected
	# $8 -> traffic

# 	set -x

	OP=LOGOUT

	unset LOGOUT

	append_to_FILE "`_date` op: INFO uid: $5, ap: $4, ip: $2, mac: $1, logout: $6, connected: $7, traffic: $8" $FILE_LOG.info

	check_for_user_already_connected "$1" "$2" "$3" "$4" "$5"

	# NB: FILE_CTX e' settato da get_user_context_connection() che e' chiamato da check_for_user_already_connected()...

	if [ -z "$FILE_CTX" -o "$OP" = "RENEW" ]; then

		IP=$2
		MAC=$1
		GATEWAY=$3

		if [ "$OP" = "RENEW" ]; then
			anomalia 7
		else
			save_connection_context $4 $5 $3 $1 $2 # save connection context data on file (ap uuid gateway mac ip) to avoid another anomalia...

			anomalia 6
		fi

	elif [ $6 -ne 0 ]; then # logout

		LOGOUT=true

		# we remove the connection context data saved on file and nocat data saved on file
		rm -f $FILE_CTX $DIR_REQ/$2.req

	fi

	FILE_CNT=$DIR_CNT/$5
	# --------------------------------------------------------------------
	# WE CHECK FOR THE TRAFFIC REMAIN FOR CONNECTION (BYTES) SAVED ON FILE
	# --------------------------------------------------------------------
	TRAFFIC=0

	if [ -s $FILE_CNT.traffic ]; then
		read TRAFFIC < $FILE_CNT.traffic

		let "TRAFFIC = TRAFFIC - $8"

		if [ $TRAFFIC -lt 0 ]; then
			TRAFFIC=0
		fi
	fi
	# ---------------------------------------------------------
	# we save the remain traffic for connection (bytes) on file
	# ---------------------------------------------------------
	write_FILE $TRAFFIC $FILE_CNT.traffic

	if [ $TRAFFIC -eq 0 -a -z "$LOGOUT" ]; then

		LOGOUT=true

		ask_nodog_to_logout_user

	fi
	# ---------------------------------------------------------

	# --------------------------------------------------------------------
	# WE CHECK FOR THE TIME REMAIN FOR CONNECTION (SECS) SAVED ON FILE
	# --------------------------------------------------------------------
	TIMEOUT=0

	if [ -s $FILE_CNT.timeout ]; then
		read TIMEOUT < $FILE_CNT.timeout

		let "TIMEOUT = TIMEOUT - $7"

		if [ $TIMEOUT -lt 0 ]; then
			TIMEOUT=0
		fi
	fi
	# ---------------------------------------------------------
	# we save the time remain for connection (secs) on file
	# ---------------------------------------------------------
	write_FILE $TIMEOUT $FILE_CNT.timeout

	if [ $TIMEOUT -eq 0 -a -z "$LOGOUT" ]; then

		LOGOUT=true

		ask_nodog_to_logout_user

	fi
	# ---------------------------------------------------------

	if [ $6 -eq -1 ]; then # disconneted (logout implicito)

		OP=EXIT

		if [ $TRAFFIC -gt 0 ]; then

			let "TIMEOUT = TIMEOUT + 300" # 5 minuti bonus

			write_FILE $TIMEOUT $FILE_CNT.timeout

		fi
	fi

	if [ $6 -ne 0 ]; then # logout

		write_to_LOG "$5" "$4" "$2" "$1" "$TIMEOUT" "$TRAFFIC"

	fi

	if [ $# -gt 8 ]; then

		shift 8

		info_notified_from_nodog "$@"

	elif [ -n "$LOGOUT" ]; then

		OUTPUT="<html><body>LOGOUT</body></html>"

	else

		OUTPUT="<html><body>OK</body></html>"

	fi

# 	set +x
}

reset_policy() {

#	set -x

	for FILE in `ls $DIR_CNT/*.timeout 2>/dev/null`
	do
		write_FILE $MAX_TIME $FILE
	done

	for FILE in `ls $DIR_CNT/*.traffic 2>/dev/null`
	do
		write_FILE $MAX_TRAFFIC $FILE
	done

	OUTPUT="<html><body>OK</body></html>"

# 	set +x
}

get_users_info() {

#	set -x

	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# cat $DIR_REQ/*.req 2>/dev/null | cut -f 1-2 -d' ' | uniq >/tmp/ACCESS_POINT.lst 2>/dev/null
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# ACCESS_POINT_LIST=$PIAZZE_FI/etc/ACCESS_POINT.lst
	# ------------------------------------------------------------------------------------------------------------------------------------------------

	NUM_ACCESS_POINT=`wc -l < $ACCESS_POINT_LIST 2>/dev/null`

	if [ $NUM_ACCESS_POINT -gt 0 ]; then

		while read AP GATEWAY
		do

			ask_nodog_to_check_for_users_info # we request nodog to check for users logout or disconnect...

		done < $ACCESS_POINT_LIST

	fi

	OUTPUT="<html><body>OK</body></html>"
}

get_user_nome_cognome() {

	TMP_FORM_FILE=$DIR_REG/$UUID.reg

	load_value_session

	USER="$v1 $v2"
}

get_stato_utente() {

#	set -x

	get_user_context_connection

	if [ -z "$GATEWAY" ]; then
		message_page "Utente non connesso" "Utente non connesso"
	else

		get_user_nome_cognome

		ask_nodog_status_user

		printf "`cat $FORM_FILE_DIR/${BASE_NAME}.tmpl 2>/dev/null`" "`date`" $AP "$USER" "$OUTPUT" "$BACK_TAG" > $DIR_STAT/$UUID.html 2>/dev/null

		echo -e "Location: /wi-auth/stat/$UUID.html\r\n\r"

	fi

	exit 0
}

info_start_ap() {

#	set -x

	# $1 -> ap

	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# *.req (AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID)
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# *.cxt (AP UUID GATEWAY MAC IP)
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 055340773 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105
	# ------------------------------------------------------------------------------------------------------------------------------------------------

	LIST=`grep -l "^$1 " $DIR_REQ/*.req $DIR_CTX/*.ctx 2>/dev/null`

	if [ -n "$LIST" ]; then

		OP=QUIT
		LIST_SAFE=""

		for FILE in $LIST
		do
			unset GATEWAY

			SUFFIX="${FILE##*.}"

			if [ "$SUFFIX" = "req" ]; then

				read AP GATEWAY MAC IP REDIRECT NOCAT_TIMEOUT TOKEN UUID < $FILE

			elif [ "$SUFFIX" = "ctx" ]; then

				read AP UUID GATEWAY MAC IP < $FILE

			fi

			if [ "$AP" = "$1" -a "$GATEWAY" = "${REMOTE_ADDR}:5280" ]; then

				LIST_SAFE="$FILE $LIST_SAFE"

				if [ "$SUFFIX" = "ctx" ]; then

					FILE_CNT=$DIR_CNT/$UUID

					if [ -s $FILE_CNT.traffic ]; then
						read TRAFFIC < $FILE_CNT.traffic
					fi

					if [ -s $FILE_CNT.timeout ]; then
						read TIMEOUT < $FILE_CNT.timeout
					fi

					write_to_LOG "$UUID" "$AP" "$IP" "$MAC" "$TIMEOUT" "$TRAFFIC"

				fi

			fi

		done

		rm -f $LIST_SAFE

	fi

	OUTPUT="<html><body>OK</body></html>"
}

check_phone_number() {

# 	set -x

	# -----------------------------------------
	# $1 -> CALLER_ID
	# -----------------------------------------

	# Check for italian prefix

	CALLER_ID=`echo -n "$1" | \
					awk 'BEGIN {phoneNumber=""}
					{

					if (match($1,"^+") == 0 && match($1,"^00") == 0) {
						phoneNumber="+39"$1	
					} else {
						phoneNumber=$1
					}

					if (match(phoneNumber,"^[0-9]+$") == 0 && match(phoneNumber,"^+[0-9]+$") == 0) {
						print phoneNumber": ""Invalid phone number"; exit (1);
					}

					if (match(phoneNumber,"^+39") == 0 && match(phoneNumber,"^0039") == 0) {
						print phoneNumber": ""Not italian number"; exit (1);
					}

					if (match(phoneNumber,"^[0-9]+$")) {
						print substr(phoneNumber,5);
					}

					if (match(phoneNumber,"^+[0-9]+$")) {
						print substr(phoneNumber,4);
					}

					}' 2>/dev/null`

	EXIT_VALUE=$?

# 	set +x
}

registra_adesione()
{
#	set -x

	check_phone_number "${15}${16}" # numero cellulare

	if [ $EXIT_VALUE -ne 0 ]; then
		message_page "$CALLER_ID" "$CALLER_ID"
	fi

	TMP_FORM_FILE=$DIR_REG/$CALLER_ID.reg

	save_value_session "$@"

 	ask_to_LDAP ldapadd "$LDAP_USER_PARAM" "
dn: waUid=$CALLER_ID,$WIAUTH_USER_BASEDN
objectClass: top
objectClass: waUser
waActive: TRUE
waUid: $CALLER_ID
waCell: $CALLER_ID
"

	if [ $EXIT_VALUE -eq 68 ]; then
		message_page "Utente giá registrato" "Utente giá registrato"
	fi

	UUID=`uuidgen 2>/dev/null`

	WA_CARDID=${UUID:24:12}

 	ask_to_LDAP ldapadd "$LDAP_CARD_PARAM" "
dn: waCid=$UUID,$WIAUTH_CARD_BASEDN
objectClass: top
objectClass: waCard
waCid: $UUID
waPin: $CALLER_ID
waCardId: $WA_CARDID
waRevoked: FALSE
waValidity: 180
"

	if [ $EXIT_VALUE -eq 68 ]; then
		message_page "Utente giá registrato" "Utente giá registrato (ldap branch card)"
	fi

	BASE_NAME=post_registrazione

	print_page $CALLER_ID polling_attivazione $CALLER_ID

#	set +x
}

card_activation() {

# 	set -x

	# -----------------------------------------
	# $1 -> CALLER_ID
	# -----------------------------------------

	check_phone_number "$1"

	if [ $EXIT_VALUE -ne 0 ]; then

		logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: $CALLER_ID"

		return

	fi

	# Search card by pin

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" "waPin=$CALLER_ID"

	if [ -z "$OUTPUT" ]; then

		MSG="Utente $CALLER_ID non registrato!"

		logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: $MSG"

		return

	fi

	# Verify the card is already activated

	WA_CID=`echo "$OUTPUT"	  | awk '/^waCid/{print $2}'	  2>/dev/null`
	WA_USEDBY=`echo "$OUTPUT" | awk '/^waUsedBy/{print $2}' 2>/dev/null`

	if [ -n "$WA_USEDBY" ]; then

		MSG="Utente $CALLER_ID giá attivato!"

		logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: $MSG"

		return

	fi

	PASSWORD=`apg -a 1 -M n -n 1 -m 6 -x 6` # generate PASSWORD

	# Update card with a new LOGIN/PASSWORD

	ask_to_LDAP ldapmodify "-c $LDAP_CARD_PARAM" "
dn: waCid=$WA_CID,ou=cards,o=unwired-portal
changetype: modify
add: waLogin
waLogin: $CALLER_ID
-
add: waPassword
waPassword: $PASSWORD
-
add: waUsedBy
waUsedBy: $CALLER_ID
-
"

	if [ $EXIT_VALUE -ne 0 ]; then

		MSG="Update card failed!"

		logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: $MSG"

		return

	fi

	OUTPUT="<html><body>OK</body></html>"

	logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: Login <$CALLER_ID>"
	logger -p $LOCAL_SYSLOG_SELECTOR "$BASE_NAME: Password <$PASSWORD>"

# 	set +x
}

upload_log_ap() {

# 	set -x

	# -----------------------------------------
	# $1 -> path file upload
	# -----------------------------------------

   mv $1 $HISTORICAL_LOG_DIR

	OUTPUT="<html><body>OK</body></html>"

# 	set +x
}

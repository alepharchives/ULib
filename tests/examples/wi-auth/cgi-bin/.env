#!/bin/bash

set_ENV() {

	# global var
	BASE_NAME=$(basename $1 .sh)

	if [ -z "$HTTP_ACCEPT_LANGUAGE" -o ! -d ../form/$HTTP_ACCEPT_LANGUAGE ]; then
		HTTP_ACCEPT_LANGUAGE=en
	fi

	FORM_FILE_DIR=../form/$HTTP_ACCEPT_LANGUAGE

	# environment
 	source /srv/wifi-portal-siena/etc/environment.conf

	# we can do services... ?
	if [ -x $WIFI_PORTAL_HOME/ANOMALIA ]; then
		ANOMALIA_page
	fi

# --------------------------------
#  session cookie (no NAT)
# --------------------------------
	SESSION_ID=$REMOTE_ADDR
# --------------------------------
#  session cookie (with NAT)
# --------------------------------
#	if [ -n "$HTTP_COOKIE" ]; then
#		SESSION_ID=$HTTP_COOKIE
#	else
#     SET_COOKIE=SESS_$$
#		SESSION_ID=$SET_COOKIE
#	fi
# --------------------------------

	# ---------------------------------------------------------------------
	# NB: se cambia qualcosa qui, bisogna cambiarlo anche nel .env di admin
	# ---------------------------------------------------------------------
	DIR_REQ=../request
	DIR_CTX=../login

	# ---------------------------------------------------------------------

	TRAFFIC=0
	NOCAT_TIMEOUT=0

	EXIT_VALUE=0
	TELEFONO="055-055"
	BACK_TAG="<a class=\"back\" href=\"#\" onclick=\"history.go(-1);return false;\">INDIETRO</a>"
	MSG_ANOMALIA="Errore di autenticazione (anomalia %s). Si prega di riprovare, se il problema persiste contattare: $TELEFONO"
	LDAP_USER_PARAM="-x -D $WIAUTH_USER_LDAP_BINDDN -w $WIAUTH_USER_LDAP_PWD -h $WIAUTH_USER_LDAP_SERVER -p $WIAUTH_USER_LDAP_PORT"
	LDAP_CARD_PARAM="-x -D $WIAUTH_CARD_LDAP_BINDDN -w $WIAUTH_CARD_LDAP_PWD -h $WIAUTH_CARD_LDAP_SERVER -p $WIAUTH_CARD_LDAP_PORT"

	if [ -n "$HTTP_HEADER_HOST" ]; then
		SERVER=$HTTP_HEADER_HOST
	else
		SERVER=$SERVER_ADDR
	fi

	export OUTPUT BASE_NAME FORM_FILE_DIR OP FILE_LOG DIR_CTX DIR_REQ FILE_CTX TRAFFIC \
			 NOCAT_TIMEOUT MAC IP GATEWAY AP TMP_FORM_FILE UUID SET_COOKIE SESSION_ID CALLER_ID \
			 USER SIGNED_DATA BACK_TAG PROT SERVER UUID_TO_APPEND LDAP_USER_PARAM \
			 LDAP_CARD_PARAM EXIT_VALUE CONNECTION_CLOSE TELEFONO
}

write_OUTPUT() {

	if [ -n "$1" ]; then

		if [ -n "$CONNECTION_CLOSE" ]; then
			echo -e "Connection: close\r"
		fi

		if [ -n "$SET_COOKIE" ]; then

			# REQ: Set-Cookie: TODO[ data expire path domain secure HttpOnly ]
			# ----------------------------------------------------------------------------------------------------------------------------
			# string -- Data to put into the cookie         -- must
			# int    -- Lifetime of the cookie in HOURS     -- must (0 -> valid until browser exit)
			# string -- Path where the cookie can be used   --  opt
			# string -- Domain which can read the cookie    --  opt
			# bool   -- Secure mode                         --  opt
			# bool   -- Only allow HTTP usage               --  opt
			# ----------------------------------------------------------------------------------------------------------------------------
			# RET: Set-Cookie: ulib_sid=data&expire&HMAC-MD5(data&expire); expires=expire(GMT); path=path; domain=domain; secure; HttpOnly

			echo "Set-Cookie: TODO[ $SET_COOKIE 4320 ]" # 180 days

		fi

		echo -e "Content-Type: text/html; charset=utf8\r\n\r"
		echo -n -E "$1"

		exit $EXIT_VALUE 

	fi
}

anomalia() {

	# ---------------------------------------------
	# $1 -> exit value
	# ---------------------------------------------
	# 2 write_FILE
	# 3 append_to_FILE
	# 4 sign_data
	# 5 send_request_to_nodog (curl | uclient)
	# 6 info_notified_from_nodog (missing ctx)
	# 7 info_notified_from_nodog (RENEW)
	# 8 ask_to_LDAP
	# 9 login_request (req without ctx)
	# ---------------------------------------------

	EXIT_VALUE=$1

	MSG=`printf "$MSG_ANOMALIA" 00$1`

	case "$1" in
	9)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: login_request() failure (anomalia 009)"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"
	;;
	8)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: Servizio LDAP non disponibile (anomalia 008)"

		if [ -n "$ADMIN_CONTEXT" ]; then
			MSG=`printf "Servizio LDAP non disponibile (anomalia %s). Contattare l'assistenza." 00$1`
		else
			BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		fi

		message_page "Servizio LDAP non disponibile" "$MSG"
	;;
	7 | 6)
		MSG=`printf "$BASE_NAME: info_notified_from_nodog() failure (anomalia %s)" 00$1 file_ctx=\"$FILE_CTX\"`

		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $MSG"

		ask_nodog_to_logout_user

		return
	;;
	5)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: send_request_to_nodog() failure (anomalia 005) gateway=$GATEWAY"

		return
	;;
	4)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: sign_data() failure (anomalia 004)"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"
	;;
	*)
		chmod 777 $WIFI_PORTAL_HOME/ANOMALIA

		ANOMALIA_page
	;;
	esac

	exit $1
}

write_FILE() {

	# $1 -> data
	# $2 -> filename
	# $3 -> option

	echo $3 "$1" > $2

	if [ $? -ne 0 ]; then
		anomalia 2
	fi
}

append_to_FILE() {

	# $1 -> data
	# $2 -> filename

	echo "$1" >> $2

	if [ $? -ne 0 ]; then
		anomalia 3
	fi
}

_date() { date '+%Y/%m/%d %H:%M:%S' ; }

write_to_LOG() {

	# $1 -> uid
	# $2 -> ap
	# $3 -> ip
	# $4 -> mac
	# $5 -> timeout
	# $6 -> traffic

	# --------------------------------------------------------------------
	# GET REAL UID ON FILE (UUID_TO_LOG)
	# --------------------------------------------------------------------
	FILE_UID=$DIR_REQ/$1.uid

	read UUID_TO_LOG < $FILE_UID

	if [ -z "$UUID_TO_LOG" ]; then
		UUID_TO_LOG=$1
	fi
	# --------------------------------------------------------------------

	RIGA="`_date` op: $OP, uid: $UUID_TO_LOG, ap: $2, ip: $3, mac: $4, timeout: $5, traffic: $6"

	append_to_FILE "$RIGA" $FILE_LOG

	sync

	logger -p $REMOTE_SYSLOG_SELECTOR "$PORTAL_NAME: $RIGA"
}

send_request_to_nodog() {

	# $1 -> url
	# $2 -> filename to save output
	# $3 -> option

	# we send request to nodog...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	#UTRACE="0 10M 0"
	#UOBJDUMP="0 100k 10"
	#USIMERR="error.sim"
	export UTRACE UOBJDUMP USIMERR

	OUTPUT=`$CLIENT_HTTP $3 "$1" 2>>/tmp/CLIENT_HTTP.err`

	if [ $? -ne 0 ]; then
		anomalia 5
	fi

	if [ -n "$2" -a -n "$OUTPUT" ]; then

		write_FILE "$OUTPUT" $2

		unset OUTPUT

	fi
}

ask_to_LDAP() {

#	set -x

	# $1 -> cmd
	# $2 -> param
	# $3 -> option
	# $4 -> filter_option

	TMPFILE=/tmp/ask_to_LDAP.$$

	if [ "$1" = ldapsearch ]; then
		OUTPUT=`$1 $2 "$3" $4 2>$TMPFILE`
	else
		$1 $2 <<END >$TMPFILE 2>&1
$3
END
	fi

	EXIT_VALUE=$?

 	if [ $EXIT_VALUE -eq 0 ]; then

 		rm -f $TMPFILE

 	elif [ -s $TMPFILE ]; then

 		grep '(-1)' < $TMPFILE # Can't contact LDAP server (-1)

 		if [ $? -eq 0 ]; then
			anomalia 8
 		fi

 	fi

#	set +x
}

print_page() {

	OUTPUT=`cat $FORM_FILE_DIR/$BASE_NAME.tmpl 2>/dev/null`

	if [ $# -ne 0 ]; then
		OUTPUT=`printf "$OUTPUT" "$@" 2>/dev/null`
	fi
}

logout_page() {

	print_page
}

logout_popup() {

	# $1 -> uid
	# $2 -> gateway

	CONNECTION_CLOSE=1

	BASE_NAME=logout_popup

	print_page "$1"
}

message_page() {

	BASE_NAME=message_page

	print_page "$@" "$BACK_TAG"

	write_OUTPUT "$OUTPUT"
}

ANOMALIA_page() {

	BASE_NAME=ANOMALIA_page

	print_page "$@"

	write_OUTPUT "$OUTPUT"
}

save_connection_request() {

	# $1 -> ap
	# $2 -> gateway
	# $3 -> mac
	# $4 -> ip
	# $5 -> redirect
	# $6 -> timeout
	# $7 -> token

	# ---------------------------------------------------------------------------------
	# SAVE REQUEST CONTEXT DATA ON FILE (AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID)
	# ---------------------------------------------------------------------------------
	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	write_FILE "$1 $2 $3 $4 $5 $6 $7" $DIR_REQ/$SESSION_ID.req "-n"
	# ---------------------------------------------------------------------------------
}

save_connection_context() {

	# $1 -> ap
	# $2 -> uid
	# $3 -> gateway
	# $4 -> mac
	# $5 -> ip

	# --------------------------------------------------------------------
	# SAVE CONNECTION CONTEXT DATA ON FILE (AP UUID GATEWAY MAC IP)
	# --------------------------------------------------------------------
	FILE_CTX=$DIR_CTX/$2.ctx

	write_FILE "$1 $2 $3 $4 $5" $FILE_CTX
	# --------------------------------------------------------------------
}

get_user_context_connection() {

	# $1 -> uid

	if [ $# -eq 1 ]; then
		FILE_CTX=$DIR_CTX/$1.ctx
	else
		FILE_CTX=`grep -l $REMOTE_ADDR $DIR_CTX/*.ctx 2>/dev/null`
	fi

	# data connection context saved on file
	# -------------------------------------
	# ap uid gateway mac ip

	if [ -n "$FILE_CTX" -a -s "$FILE_CTX" ]; then
		read AP UUID GATEWAY MAC IP < $FILE_CTX
	else
		unset FILE_CTX AP UUID GATEWAY MAC IP
	fi
}

check_for_user_already_connected() {

# 	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> gateway
	# $4 -> ap
	# $5 -> uid

	get_user_context_connection $5

	if [ -n "$FILE_CTX" ]; then

		if [ "$MAC"		 != "$1" -o \
			  "$IP"		 != "$2" -o \
			  "$GATEWAY" != "$3" -o \
			  "$AP"		 != "$4" ]; then

			OP=RENEW

		fi

	fi

# 	set +x
}

user_has_valid_MAC() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap

	# List of allowed MAC

	FILE=$DIR_CTX/.MAC_WHITE_LIST

	if [ -s $FILE ]; then

		while read MAC
		do

			if [ "$MAC" = "$1" ]; then

				OP=MAC_AUTH

				send_ticket "$@" "$MAC" 

			fi

		done < $FILE

	fi
}

user_has_valid_cert() {

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_USER_BASEDN $LDAP_USER_PARAM" \
			"(&(objectClass=waUser)(&(waIssuer=$SSL_CLIENT_I_DN)(waSerial=$SSL_CLIENT_CERT_SERIAL)(waActive=TRUE)))"

	if [ -n "$OUTPUT" ]; then

		# NoCat is calling for auth, redirect back to the gateway appending a signed GPG ticket that will signal NoCat to unlock the firewall...

		USER=`echo "$OUTPUT" | grep 'waUid: ' | cut -f2 -d' ' 2>/dev/null`

		if [ -z "$USER" ]; then
			USER=unknow
		fi

		OP=CERT_AUTH

		send_ticket "$@" "$USER"

	fi
}

user_welcome() {

#	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap

	save_connection_request $7 $4 $1 $2 $3 $5 $6

	get_user_context_connection

	if [ -n "$GATEWAY" ]; then

		# check if he is still connected...

		ask_nodog_status_user

		echo "$OUTPUT" | grep PERMIT >/dev/null 2>/dev/null

		if [ $? -ne 0 ]; then

			unset UUID

			rm -f $FILE_CTX # NB: FILE_CTX e' settato da get_user_context_connection()...

		fi
	fi

	CONNECTION_CLOSE=1

	if [ -n "$UUID" ]; then
		# connesso...
		write_OUTPUT "<html><body>OK</body></html>"
	else
		# non connesso
		UUID_TO_APPEND=1

		user_has_valid_MAC "$@"

		if [ -n "$SSL_CLIENT_CERT_SERIAL" ]; then
			user_has_valid_cert "$@"
		fi

		print_page "$@"
	fi

#	set +x
}

login_with_problem() {

	BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"

	message_page "Login error" "Errore di autenticazione. Si prega di riprovare, se il problema persiste contattare: $TELEFONO"
}

login_request() {

#	set -x

	# $1 -> realm
	# $2 -> uid
	# $3 -> password
	# $4 -> bottone

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		login_with_problem
	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT NOCAT_TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -n "$UUID" ]; then

		FILE_CTX=$DIR_CTX/$UUID.ctx

		if [ ! -s $FILE_CTX ]; then
			anomalia 9
		fi

		BACK_TAG=""

		message_page "Login error" "Sei gia' loggato!"

	fi

	UUID_TO_APPEND=1

	auth_check_card "$MAC" $IP "$REDIRECT" $GATEWAY $NOCAT_TIMEOUT "$TOKEN" $AP "$@"

#	set +x
}

post_login() {

#	set -x

	# $1 -> uid
	# $2 -> gateway
	# $3 -> redirect
	# $4 -> ap
	# $5 -> ip
	# $6 -> mac
	# $7 -> timeout
	# $8 -> traffic

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		login_with_problem
	fi

	FILE_CTX=$DIR_CTX/$1.ctx

	if [ -s $FILE_CTX ]; then

		BACK_TAG=""

		message_page "PostLogin error" "Sei gia' loggato!"

	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT NOCAT_TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -z "$UUID" ]; then
		login_with_problem
	fi

	OP=LOGIN

	write_to_LOG "$1" "$4" "$5" "$6" "$7" "$8"

	# --------------------------------------------------------------------
	# SAVE CONNECTION CONTEXT DATA ON FILE (AP UUID GATEWAY MAC IP)
	# --------------------------------------------------------------------
	save_connection_context $4 $1 $2 $6 $5
	# --------------------------------------------------------------------

	CONNECTION_CLOSE=1

	print_page "$1" "$2" "$3" "$1" "$3" "$3"

#	set +x
}

ask_nodog_status_user() {

	# we request the status of the indicated user...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	send_request_to_nodog "http://$GATEWAY/status?ip=$REMOTE_ADDR"
}

ask_nodog_to_logout_user() {

	# we request to logout this user with the old ip from the associated gateway...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	SIGNED_DATA="ip=$IP&mac=$MAC"

	sign_data

	send_request_to_nodog "http://$GATEWAY/logout?$SIGNED_DATA"
}

ask_nodog_to_check_for_users_info() {

#	set -x

	# we request nodog to check for users logout or disconnect...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	FILE_TMP=/tmp/nodog.check.$$

	send_request_to_nodog "http://$GATEWAY/check" $FILE_TMP "-i"

	if [ -s $FILE_TMP ]; then

		read HTTP_VERSION HTTP_STATUS HTTP_DESCR < $FILE_TMP

		if [ "$HTTP_STATUS" = "204" ]; then # 204 - HTTP_NO_CONTENT

			sleep 9

			ask_nodog_to_check_for_users_info

		fi

		rm -f $FILE_TMP
	fi

#	set +x
}

sign_data() {

	SIGNED_DATA=`echo -n -E "$SIGNED_DATA" | openssl des3 -pass pass:200912281747 -a -e | tr -d '\n'`
}

send_ticket() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap
	# $8 -> uid

	# -------------------------------------------------------------
	# CHECK FOR CHANGE OF CONNECTION CONTEXT FOR SAME USER ID
	# -------------------------------------------------------------
	check_for_user_already_connected "$1" "$2" "$4" "$7" "$8"

	if [ "$OP" = "RENEW" ]; then
		ask_nodog_to_logout_user
	fi

	if [ -z "$REDIRECT_DEFAULT" ]; then
		REDIRECT_DEFAULT=$3
	fi

	# la prima linea deve essere vuota... (vedi conf.c:36  for ( i = 1; lines[i] != NULL; i++ ) ....)

	SIGNED_DATA="

Action   Permit
Mode	   Login
Redirect	$PROT://$SERVER/postlogin?uid=$8&gateway=$4&redirect=$REDIRECT_DEFAULT&ap=$7&ip=$2&mac=$1&timeout=$NOCAT_TIMEOUT&traffic=$TRAFFIC
Mac		$1
Timeout	$NOCAT_TIMEOUT
Traffic	$TRAFFIC
Token		$6
User		$8"

	sign_data

	write_to_LOG "$8" "$7" "$2" "$1" "$NOCAT_TIMEOUT" "$TRAFFIC"

	if [ -n "$UUID_TO_APPEND" ]; then
		append_to_FILE " $8" $REQ_FILE # si aggiunge UUID alla request...
	fi

	echo -e "Location: http://$4/?ticket=$SIGNED_DATA\r\n\r"

	exit 0
}

get_timeout_secs() {

	DSTART=`printf "%4s-%2s-%2s %2s:%2s:%2s" ${1:0:4} ${1:4:2} ${1:6:2} ${1:8:2} ${1:10:2} ${1:12:2} 2>/dev/null`
	  DEND=`printf "%4s-%2s-%2s %2s:%2s:%2s" ${2:0:4} ${2:4:2} ${2:6:2} ${2:8:2} ${2:10:2} ${2:12:2} 2>/dev/null`

	START=`date --date="$DSTART" +%s 2>/dev/null`
	  END=`date --date="$DEND"   +%s 2>/dev/null`

	let "NOCAT_TIMEOUT = $END - $START"
}

auth_check_card() {

	# $1	-> mac
	# $2  -> ip
	# $3	-> redirect
	# $4	-> gateway
	# $5	-> timeout
	# $6	-> token
	# $7	-> ap
	# $8	-> domain (es: 10_piazze, paas)
	# $9	-> uid
	# $10	-> pass
	# $11 -> button

	# Ex: 00:15:58:0c:9e:26 10.30.1.102 http://ap1 10.30.1.112:5280 86400 10.30.1.102&1255107570&42cb373714c ap0.rs paas 3397363258 pswd Entra

	OP=PASS_AUTH

	# ---------------------------------------------------
	# TEST (bypass LDAP)
	# ---------------------------------------------------
	# send_ticket "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$9"
	# ---------------------------------------------------

#	set -x

	if [ -z "$9" -o -z "${10}" ]; then
		message_page "Impostare utente e password" "Impostare utente e password"
	fi

	# Check 1: Wrong user and/or password

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" "(&(waLogin=$9)(waPassword=${10}))"

	if [ -z "$OUTPUT" ]; then
		message_page "Utente e/o Password errato/i" "Credenziali errate!"
	fi

	WA_UID=`echo "$OUTPUT" | grep 'waUsedBy: ' | cut -f2 -d' ' 2>/dev/null`

	# Check 4: Expired registration

	GEN_TIME=`date +%Y%m%d%H%M%SZ` # GeneralizedTime YYYYmmddHH[MM[SS]][(./,)d...](Z|(+/-)HH[MM])

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" \
			"(&(objectClass=waCard)(&(waLogin=$9)(waPassword=${10})(waRevoked=FALSE)(|(!(waNotAfter=*))(waNotAfter>=$GEN_TIME))))"

	if [ -z "$OUTPUT" ]; then
		message_page "Registrazione scaduta" "La tua registrazione e' scaduta!"
	fi

	NOT_AFTER=`echo "$OUTPUT" | grep 'waNotAfter: ' | cut -f2 -d' ' 2>/dev/null`

	if [ -n "$NOT_AFTER" ]; then
		get_timeout_secs "$GEN_TIME" "$NOT_AFTER"
	else

		OP=FIRST_PASS_AUTH

		# Update card with a new generated waNotAfter

		DN=`		  echo "$OUTPUT" | grep 'dn: '			| cut -f2 -d' ' 2>/dev/null`
		VALIDITY=` echo "$OUTPUT" | grep 'waValidity: ' | cut -f2 -d' ' 2>/dev/null`

		let "NOCAT_TIMEOUT = $VALIDITY * 86400"

		NOT_AFTER=`date --date="+$VALIDITY days" +%Y%m%d%H%M%SZ 2>/dev/null`

		ask_to_LDAP ldapmodify "-c $LDAP_CARD_PARAM" "
dn: $DN
changetype: modify
add: waNotAfter
waNotAfter: $NOT_AFTER
"

	fi

	# --------------------------------------------------------------------
	# SAVE REAL UID ON FILE (UUID_TO_LOG)
	# --------------------------------------------------------------------
	FILE_UID=$DIR_REQ/$9.uid

	write_FILE "$WA_UID" $FILE_UID
	# --------------------------------------------------------------------

	# redirect back to the gateway appending a signed GPG ticket that will signal NoCat to unlock the firewall...

	send_ticket "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$9"
}

request_to_logout_from_user() {

# 	set -x

	# nocat data saved on file
	# ------------------------
	# $1 -> ap
	# $2 -> gateway
	# $3 -> mac
	# $4 -> ip
	# $5 -> redirect
	# $6 -> timeout
	# $7 -> token

	unset BACK_TAG

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		message_page "ID di sessione mancante" "Utente non connesso (session id: $SESSION_ID)"
	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT NOCAT_TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -n "$UUID" -a -s $DIR_CTX/$UUID.ctx ]; then

		ask_nodog_to_logout_user

		BASE_NAME=ringraziamenti

		print_page

	else
		message_page "Utente non connesso" "Utente non connesso"
	fi

#	set +x
}

info_notified_from_nodog() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> gateway
	# $4 -> ap
	# $5 -> uid
	# $6 -> logout
	# $7 -> connected
	# $8 -> traffic

# 	set -x

	OP=LOGOUT

	unset LOGOUT

	append_to_FILE "`_date` op: INFO uid: $5, ap: $4, ip: $2, mac: $1, logout: $6, connected: $7, traffic: $8" $FILE_LOG.info

	check_for_user_already_connected "$1" "$2" "$3" "$4" "$5"

	# NB: FILE_CTX e' settato da get_user_context_connection() che e' chiamato da check_for_user_already_connected()...

	if [ -z "$FILE_CTX" -o "$OP" = "RENEW" ]; then

		IP=$2
		MAC=$1
		GATEWAY=$3

		if [ "$OP" = "RENEW" ]; then
			anomalia 7
		else
			save_connection_context $4 $5 $3 $1 $2 # save connection context data on file (ap uuid gateway mac ip) to avoid another anomalia...

			anomalia 6
		fi

	elif [ $6 -ne 0 ]; then # logout

		LOGOUT=true

		# we remove the connection context data saved on file and nocat data saved on file
		rm -f $FILE_CTX $DIR_REQ/$2.req

	fi

	if [ $6 -eq -1 ]; then # disconneted (logout implicito)

		OP=EXIT

	fi

	if [ $6 -ne 0 ]; then # logout

		write_to_LOG "$5" "$4" "$2" "$1" "$TIMEOUT" "$TRAFFIC"

	fi

	if [ $# -gt 8 ]; then

		shift 8

		info_notified_from_nodog "$@"

	elif [ -n "$LOGOUT" ]; then

		OUTPUT="<html><body>LOGOUT</body></html>"

	else

		OUTPUT="<html><body>OK</body></html>"

	fi

# 	set +x
}

get_users_info() {

#	set -x

	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# cat $DIR_REQ/*.req 2>/dev/null | cut -f 1-2 -d' ' | uniq >/tmp/ACCESS_POINT.lst 2>/dev/null
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# ACCESS_POINT_LIST=$WIFI_PORTAL_HOME/etc/ACCESS_POINT.lst
	# ------------------------------------------------------------------------------------------------------------------------------------------------

	NUM_ACCESS_POINT=`wc -l < $ACCESS_POINT_LIST 2>/dev/null`

	if [ $NUM_ACCESS_POINT -gt 0 ]; then

		while read AP GATEWAY
		do

			ask_nodog_to_check_for_users_info # we request nodog to check for users logout or disconnect...

		done < $ACCESS_POINT_LIST

	fi

	OUTPUT="<html><body>OK</body></html>"
}

info_start_ap() {

#	set -x

	# $1 -> ap

	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# *.req (AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID)
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# *.cxt (AP UUID GATEWAY MAC IP)
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 055340773 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105
	# ------------------------------------------------------------------------------------------------------------------------------------------------

	LIST=`grep -l "^$1 " $DIR_REQ/*.req $DIR_CTX/*.ctx 2>/dev/null`

	if [ -n "$LIST" ]; then

		OP=QUIT
		LIST_SAFE=""

		for FILE in $LIST
		do
			unset GATEWAY

			SUFFIX="${FILE##*.}"

			if [ "$SUFFIX" = "req" ]; then

				read AP GATEWAY MAC IP REDIRECT NOCAT_TIMEOUT TOKEN UUID < $FILE

			elif [ "$SUFFIX" = "ctx" ]; then

				read AP UUID GATEWAY MAC IP < $FILE

			fi

			if [ "$AP" = "$1" -a "$GATEWAY" = "${REMOTE_ADDR}:5280" ]; then

				LIST_SAFE="$FILE $LIST_SAFE"

				if [ "$SUFFIX" = "ctx" ]; then

					write_to_LOG "$UUID" "$AP" "$IP" "$MAC" "$TIMEOUT" "$TRAFFIC"

				fi

			fi

		done

		rm -f $LIST_SAFE

	fi

	OUTPUT="<html><body>OK</body></html>"

#	set +x
}

card_activation() {

# 	set -x

	# -----------------------------------------
	# $1 -> CALLER_ID
	# -----------------------------------------

	CALLER_ID="$1"

	# Search card by pin

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" "waPin=$CALLER_ID"

	if [ -z "$OUTPUT" ]; then

		MSG="Utente $CALLER_ID non registrato!"

		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: $MSG"

		return

	fi

	# Verify the card is already activated

	WA_CID=`echo "$OUTPUT"	  | awk '/^waCid/{print $2}'	  2>/dev/null`
	WA_USEDBY=`echo "$OUTPUT" | awk '/^waUsedBy/{print $2}' 2>/dev/null`

	if [ -n "$WA_USEDBY" ]; then

		MSG="Utente $CALLER_ID gi√° attivato!"

		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: $MSG"

		return

	fi

	PASSWORD=`apg -a 1 -M n -n 1 -m 6 -x 6` # generate PASSWORD

	# Update card with a new LOGIN/PASSWORD

	ask_to_LDAP ldapmodify "-c $LDAP_CARD_PARAM" "
dn: waCid=$WA_CID,ou=cards,o=unwired-portal
changetype: modify
add: waLogin
waLogin: $CALLER_ID
-
add: waPassword
waPassword: $PASSWORD
-
add: waUsedBy
waUsedBy: $CALLER_ID
-
"

	if [ $EXIT_VALUE -ne 0 ]; then

		MSG="Update card failed!"

		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: $MSG"

		return

	fi

	OUTPUT="<html><body>OK</body></html>"

	logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: Login <$CALLER_ID>"
	logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: Password <$PASSWORD>"

# 	set +x
}

upload_log_ap() {

# 	set -x

	# -----------------------------------------
	# $1 -> path file upload
	# -----------------------------------------

   mv $1 $HISTORICAL_LOG_DIR

	OUTPUT="<html><body>OK</body></html>"

# 	set +x
}

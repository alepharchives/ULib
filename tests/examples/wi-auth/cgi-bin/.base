#!/bin/bash

# .base

# global var
BASE_NAME=$(basename $0 .sh)

if [ -z "$HTTP_ACCEPT_LANGUAGE" -o ! -d ../form/$HTTP_ACCEPT_LANGUAGE ]; then
	HTTP_ACCEPT_LANGUAGE=en
fi

FORM_FILE_DIR=../form/$HTTP_ACCEPT_LANGUAGE

# we can do services... ?
if [ -x $WIFI_PORTAL_HOME/ANOMALIA ]; then
	ANOMALIA_page
fi

# --------------------------------
#  session cookie (no NAT)
# --------------------------------
SESSION_ID=$REMOTE_ADDR
# --------------------------------
#  session cookie (with NAT)
# --------------------------------
#	if [ -n "$HTTP_COOKIE" ]; then
#		SESSION_ID=$HTTP_COOKIE
#	else
#     SET_COOKIE=SESS_$$
#		SESSION_ID=$SET_COOKIE
#	fi
# --------------------------------

# ---------------------------------------------------------------------
# NB: se cambia qualcosa qui, bisogna cambiarlo anche nel .env di admin
# ---------------------------------------------------------------------
DIR_REQ=../request
DIR_CTX=../login
DIR_CNT=../counter
DIR_POLICY=../policy
DIR_REG=../registration
DIR_STAT=../stat
# ---------------------------------------------------------------------

TIMEOUT=0
TRAFFIC=0
EXIT_VALUE=0
TELEFONO="SIENA DIGITALE"
BACK_TAG="<a class=\"back\" href=\"#\" onclick=\"history.go(-1);return false;\">INDIETRO</a>"
MSG_ANOMALIA="Problema in autenticazione (anomalia %s). Si prega di riprovare, se il problema persiste contattare: $TELEFONO"
LDAP_USER_PARAM="-x -D $WIAUTH_USER_LDAP_BINDDN -w $WIAUTH_USER_LDAP_PWD -h $WIAUTH_USER_LDAP_SERVER -p $WIAUTH_USER_LDAP_PORT"
LDAP_CARD_PARAM="-x -D $WIAUTH_CARD_LDAP_BINDDN -w $WIAUTH_CARD_LDAP_PWD -h $WIAUTH_CARD_LDAP_SERVER -p $WIAUTH_CARD_LDAP_PORT"

# ---------------------------------------------------------------------
# ????????????
# ---------------------------------------------------------------------
if [ "$HTTP_HEADER_HOST" = "i-auth/cgi-b" ]; then
	env >> /tmp/ERROR_HTTP_HEADER_HOST

	unset HTTP_HEADER_HOST
fi
# ---------------------------------------------------------------------

if [ -n "$HTTP_HEADER_HOST" ]; then
	SERVER=$HTTP_HEADER_HOST
else
	SERVER=$SERVER_ADDR
fi

export OUTPUT BASE_NAME FORM_FILE_DIR OP DIR_REQ DIR_CTX DIR_CNT DIR_POLICY DIR_REG DIR_STAT FILE_CTX TRAFFIC \
		 TIMEOUT MAC IP GATEWAY AP TMP_FORM_FILE UUID SET_COOKIE SESSION_ID CALLER_ID \
		 USER SIGNED_DATA BACK_TAG PROT SERVER UUID_TO_APPEND LDAP_USER_PARAM \
		 LDAP_CARD_PARAM EXIT_VALUE CONNECTION_CLOSE TELEFONO POLICY WA_UID

write_OUTPUT() {

	if [ -n "$1" ]; then

		if [ -n "$CONNECTION_CLOSE" ]; then
			echo -e "Connection: close\r"
		fi

		if [ -n "$SET_COOKIE" ]; then

			# REQ: Set-Cookie: TODO[ data expire path domain secure HttpOnly ]
			# ----------------------------------------------------------------------------------------------------------------------------
			# string -- Data to put into the cookie         -- must
			# int    -- Lifetime of the cookie in HOURS     -- must (0 -> valid until browser exit)
			# string -- Path where the cookie can be used   --  opt
			# string -- Domain which can read the cookie    --  opt
			# bool   -- Secure mode                         --  opt
			# bool   -- Only allow HTTP usage               --  opt
			# ----------------------------------------------------------------------------------------------------------------------------
			# RET: Set-Cookie: ulib_sid=data&expire&HMAC-MD5(data&expire); expires=expire(GMT); path=path; domain=domain; secure; HttpOnly

			echo "Set-Cookie: TODO[ $SET_COOKIE 4320 ]" # 180 days

		fi

		echo -e "Content-Type: text/html; charset=utf8\r\n\r"
		echo -n -E "$1"

		exit $EXIT_VALUE 

	else

		# BAD REQUEST

		echo -e "Status: 400\r\n\r\n" \
				  "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n" \
				  "<html><head>\r\n" \
				  "<title>400 Bad Request</title>\r\n" \
				  "</head><body>\r\n" \
				  "<h1>Bad Request</h1>\r\n" \
				  "<p>Your browser sent a request that this server could not understand.<br />\r\n" \
				  "</p>\r\n" \
				  "<hr>\r\n" \
				  "<address>ULib Server</address>\r\n" \
				  "</body></html>\r"

		exit 0

	fi
}

anomalia() {

	# ---------------------------------------------
	# $1 -> exit value
	# ---------------------------------------------
	#  2 write_FILE
	#  3 append_to_FILE
	#  4 sign_data
	#  5 send_request_to_nodog (curl | uclient)
	#  6 info_notified_from_nodog (missing ctx)
	#  7 info_notified_from_nodog (RENEW)
	#  8 ask_to_LDAP
	#  9 login_request (req without ctx)
	# 10 load_policy (policy without file)
	# ---------------------------------------------

	EXIT_VALUE=$1

	MSG=`printf "$MSG_ANOMALIA" 00$1`

	case "$1" in
	10)
		MSG=`printf "$BASE_NAME: load_policy() failure (anomalia 010)" POLICY=\"$POLICY\"`

		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $MSG"

		MSG=`printf "Servizio non disponibile (anomalia %s). Contattare l'assistenza." 00$1`

		message_page "Servizio non disponibile" "$MSG"
	;;
	9)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: login_request() failure (anomalia 009)"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"
	;;
	8)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: Servizio LDAP non disponibile (anomalia 008)"

		if [ -n "$ADMIN_CONTEXT" ]; then
			MSG=`printf "Servizio LDAP non disponibile (anomalia %s). Contattare l'assistenza." 00$1`
		else
			BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		fi

		message_page "Servizio LDAP non disponibile" "$MSG"
	;;
	7 | 6)
		MSG=`printf "$BASE_NAME: info_notified_from_nodog() failure (anomalia %s)" 00$1 file_ctx=\"$FILE_CTX\"`

		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $MSG"

		ask_nodog_to_logout_user

		return
	;;
	5)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: send_request_to_nodog() failure (anomalia 005) gateway=$GATEWAY"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"

		return
	;;
	4)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: sign_data() failure (anomalia 004)"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"
	;;
	*)
		chmod 777 $WIFI_PORTAL_HOME/ANOMALIA

		ANOMALIA_page
	;;
	esac

	exit $1
}

write_FILE() {

	# $1 -> data
	# $2 -> filename
	# $3 -> option

	echo $3 "$1" > $2

	if [ $? -ne 0 ]; then
		anomalia 2
	fi
}

append_to_FILE() {

	# $1 -> data
	# $2 -> filename

	echo "$1" >> $2

	if [ $? -ne 0 ]; then
		anomalia 3
	fi
}

_date() { date '+%Y/%m/%d %H:%M:%S' ; }

write_to_LOG() {

	# $1 -> uid
	# $2 -> ap
	# $3 -> ip
	# $4 -> mac
	# $5 -> timeout
	# $6 -> traffic

	# --------------------------------------------------------------------
	# GET REAL UID FROM FILE (UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC)
	# --------------------------------------------------------------------
	FILE_UID=$DIR_REQ/$1.uid

	read UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC < $FILE_UID

	if [ -z "$UUID_TO_LOG" ]; then
		UUID_TO_LOG=$1
	fi
	# --------------------------------------------------------------------

	RIGA="`_date` op: $OP, uid: $UUID_TO_LOG, ap: $2, ip: $3, mac: $4, timeout: $5, traffic: $6 policy: $POLICY"

	append_to_FILE "$RIGA" $FILE_LOG

	sync

	logger -p $REMOTE_SYSLOG_SELECTOR "$PORTAL_NAME: $RIGA"
}

send_request_to_nodog() {

	# $1 -> url
	# $2 -> filename to save output
	# $3 -> option

	# we send request to nodog...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	#UTRACE="0 10M 0"
	#UOBJDUMP="0 100k 10"
	#USIMERR="error.sim"
	export UTRACE UOBJDUMP USIMERR

	OUTPUT=`$CLIENT_HTTP $3 "$1" 2>>/tmp/CLIENT_HTTP.err`

	if [ $? -ne 0 ]; then
		anomalia 5
	fi

	if [ -n "$2" -a -n "$OUTPUT" ]; then

		write_FILE "$OUTPUT" $2

		unset OUTPUT

	fi
}

ask_to_LDAP() {

#	set -x

	# $1 -> cmd
	# $2 -> param
	# $3 -> option
	# $4 -> filter_option

	TMPFILE=/tmp/ask_to_LDAP.$$

	if [ "$1" = ldapsearch ]; then
		OUTPUT=`$1 $2 "$3" $4 2>$TMPFILE`
	else
		$1 $2 <<END >$TMPFILE 2>&1
$3
END
	fi

	EXIT_VALUE=$?

 	if [ $EXIT_VALUE -eq 0 ]; then

 		rm -f $TMPFILE

 	elif [ -s $TMPFILE ]; then

 		grep '(-1)' < $TMPFILE # Can't contact LDAP server (-1)

 		if [ $? -eq 0 ]; then
			anomalia 8
 		fi

 	fi

#	set +x
}

print_page() {

	OUTPUT=`cat $FORM_FILE_DIR/$BASE_NAME.tmpl 2>/dev/null`

	if [ $# -ne 0 ]; then
		OUTPUT=`printf "$OUTPUT" "$@" 2>/dev/null`
	fi
}

logout_page() {

	print_page
}

logout_popup() {

	# $1 -> uid
	# $2 -> gateway

	CONNECTION_CLOSE=1

	BASE_NAME=logout_popup

	print_page "$1"
}

message_page() {

	BASE_NAME=message_page

	print_page "$@" "$BACK_TAG"

	write_OUTPUT "$OUTPUT"
}

ANOMALIA_page() {

	BASE_NAME=ANOMALIA_page

	print_page "$@"

	write_OUTPUT "$OUTPUT"
}

load_policy() {

#	set -x

	if [ -z "$POLICY" ]; then
		POLICY=default
	fi

	POLICY_FILE=$DIR_POLICY/$POLICY

	if [ ! -s $POLICY_FILE ]; then
		anomalia 10
	fi

	source $DIR_POLICY/$POLICY

 	mkdir -p $DIR_CNT/$POLICY

#	set +x
}

save_connection_request() {

	# $1 -> data

	# ---------------------------------------------------------------------------------
	# SAVE REQUEST CONTEXT DATA ON FILE (AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID)
	# ---------------------------------------------------------------------------------
	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	write_FILE "$1" $DIR_REQ/$SESSION_ID.req "-n"
	# ---------------------------------------------------------------------------------
}

save_connection_context() {

	# $1 -> ap
	# $2 -> uid
	# $3 -> gateway
	# $4 -> mac
	# $5 -> ip

	# --------------------------------------------------------------------
	# SAVE CONNECTION CONTEXT DATA ON FILE (AP UUID GATEWAY MAC IP)
	# --------------------------------------------------------------------
	FILE_CTX=$DIR_CTX/$2.ctx

	write_FILE "$1 $2 $3 $4 $5" $FILE_CTX
	# --------------------------------------------------------------------
}

get_user_context_connection() {

	# $1 -> uid

	if [ $# -eq 1 ]; then
		FILE_CTX=$DIR_CTX/$1.ctx
	else
		FILE_CTX=`grep -l $REMOTE_ADDR $DIR_CTX/*.ctx 2>/dev/null`
	fi

	# data connection context saved on file
	# -------------------------------------
	# ap uid gateway mac ip

	if [ -n "$FILE_CTX" -a -s "$FILE_CTX" ]; then
		read AP UUID GATEWAY MAC IP < $FILE_CTX
	else
		unset FILE_CTX AP UUID GATEWAY MAC IP
	fi
}

check_for_user_already_connected() {

# 	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> gateway
	# $4 -> ap
	# $5 -> uid

	get_user_context_connection $5

	if [ -n "$FILE_CTX" ]; then

		if [ "$MAC"		 != "$1" -o \
			  "$IP"		 != "$2" -o \
			  "$GATEWAY" != "$3" -o \
			  "$AP"		 != "$4" ]; then

			OP=RENEW

		fi

	fi

# 	set +x
}

user_has_valid_MAC() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap

	# List of allowed MAC

	FILE=$DIR_CTX/.MAC_WHITE_LIST

	if [ -s $FILE ]; then

		while read MAC
		do

			if [ "$MAC" = "$1" ]; then

				# NoDog is calling for auth, redirect back to the gateway appending a signed ticket that will signal NoDog to unlock the firewall...

				OP=MAC_AUTH

				send_ticket "$@" "$MAC" 

			fi

		done < $FILE

	fi
}

user_has_valid_cert() {

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_USER_BASEDN $LDAP_USER_PARAM" \
			"(&(objectClass=waUser)(&(waIssuer=$SSL_CLIENT_I_DN)(waSerial=$SSL_CLIENT_CERT_SERIAL)(waActive=TRUE)))"

	if [ -n "$OUTPUT" ]; then

		USER=`echo "$OUTPUT" | grep 'waUid: ' | cut -f2 -d' ' 2>/dev/null`

		if [ -z "$USER" ]; then
			USER=unknow
		fi

		# NoDog is calling for auth, redirect back to the gateway appending a signed ticket that will signal NoDog to unlock the firewall...

		OP=CERT_AUTH

		send_ticket "$@" "$USER"

	fi
}

user_welcome() {

#	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap

	get_user_context_connection

	if [ -n "$GATEWAY" ]; then

		# check if he is still connected...

		ask_nodog_status_user

		echo "$OUTPUT" | grep PERMIT >/dev/null 2>&1

		if [ $? -ne 0 ]; then

			unset UUID

			rm -f $FILE_CTX # NB: FILE_CTX e' settato da get_user_context_connection()...

		fi
	fi

	if [ -z "$UUID" ]; then

		PARAM="$7 $4 $1 $2 $3 $5 $6"

		if [ "$PARAM" != "      " ]; then
			save_connection_request "$PARAM"
		fi

	fi

	ENABLE_BUTTON=a
	DISABLE_BUTTON=del
	CONNECTION_CLOSE=1

	if [ -n "$UUID" ]; then
		# connesso
		REGISTRATI=$DISABLE_BUTTON
		LOGIN=$DISABLE_BUTTON
		LOGOUT=$ENABLE_BUTTON
	   STATUS=$ENABLE_BUTTON
	else
		# non connesso
		REGISTRATI=$ENABLE_BUTTON
		LOGIN=$ENABLE_BUTTON
		LOGOUT=$DISABLE_BUTTON
	   STATUS=$DISABLE_BUTTON

		UUID_TO_APPEND=1

		user_has_valid_MAC "$@"

		if [ -n "$SSL_CLIENT_CERT_SERIAL" ]; then
			user_has_valid_cert "$@"
		fi
	fi

	CA_CERT_URL="$SERVER/CA/ServerCA.cer"

	if [ -n "$BROWSER_MSIE" ]; then
		CA_CERT_URL="$SERVER/CA/ServerCA.der"
	else
		case $HTTP_USER_AGENT in
		*AppleWebKit*KHTML*)
			CA_CERT_URL="$SERVER/wi-auth/form/$HTTP_ACCEPT_LANGUAGE/install_safari.tmpl"
		;;
		esac
	fi

	print_page https://$SERVER/login \
				  $CA_CERT_URL \
				  $SERVER $SERVER \
				  $REGISTRATI $REGISTRATI \
				  $LOGIN		  $LOGIN \
				  $LOGOUT	  $LOGOUT \
				  $STATUS	  $STATUS

#	set +x
}

login_with_problem() {

	BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"

	message_page "Login" "Problema in fase di autenticazione. Si prega di riprovare, se il problema persiste contattare: $TELEFONO"
}

login_request() {

#	set -x

	# $1 -> realm
	# $2 -> uid
	# $3 -> password
	# $4 -> bottone

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		login_with_problem
	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -n "$UUID" ]; then

		FILE_CTX=$DIR_CTX/$UUID.ctx

		if [ ! -s $FILE_CTX ]; then
			anomalia 9
		fi

		BACK_TAG=""

		message_page "Login" "Sei gia' loggato! (login_request)"

	fi

	UUID_TO_APPEND=1

	if [ "$1" = "paas" ]; then
		auth_check_card_paas "$MAC" $IP "$REDIRECT" $GATEWAY $TIMEOUT "$TOKEN" $AP "$@"
	else
		auth_check_card		"$MAC" $IP "$REDIRECT" $GATEWAY $TIMEOUT "$TOKEN" $AP "$@"
	fi

#	set +x
}

post_login() {

#	set -x

	# $1 -> uid
	# $2 -> gateway
	# $3 -> redirect
	# $4 -> ap
	# $5 -> ip
	# $6 -> mac
	# $7 -> timeout
	# $8 -> traffic

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		login_with_problem
	fi

	FILE_CTX=$DIR_CTX/$1.ctx

	if [ -s $FILE_CTX ]; then

		BACK_TAG=""

		message_page "PostLogin" "Sei gia' loggato! (post_login)"

	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -z "$UUID" ]; then
		login_with_problem
	fi

	OP=LOGIN

	write_to_LOG "$1" "$4" "$5" "$6" "$7" "$8"

	# --------------------------------------------------------------------
	# SAVE CONNECTION CONTEXT DATA ON FILE (AP UUID GATEWAY MAC IP)
	# --------------------------------------------------------------------
	save_connection_context $4 $1 $2 $6 $5
	# --------------------------------------------------------------------

	CONNECTION_CLOSE=1

	print_page "$1" "$2" "$3" "$1" "$3" "$3"

#	set +x
}

ask_nodog_status_user() {

#	set -x

	# we request the status of the indicated user...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	send_request_to_nodog "http://$GATEWAY/status?ip=$REMOTE_ADDR"

#	set +x
}

ask_nodog_to_logout_user() {

#	set -x

	# we request to logout this user with the old ip from the associated gateway...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	SIGNED_DATA="ip=$IP&mac=$MAC"

	sign_data

	send_request_to_nodog "http://$GATEWAY/logout?$SIGNED_DATA"

#	set +x
}

sign_data() {

#	set -x

	SIGNED_DATA=`echo -n -E "$SIGNED_DATA" | openssl des3 -pass pass:200912281747 -a -e | tr -d '\n'`

#	set +x
}

send_ticket() {

#	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap
	# $8 -> uid

	# -------------------------------------------------------------
	# CHECK FOR CHANGE OF CONNECTION CONTEXT FOR SAME USER ID
	# -------------------------------------------------------------
	check_for_user_already_connected "$1" "$2" "$4" "$7" "$8"

	if [ "$OP" = "RENEW" ]; then
		ask_nodog_to_logout_user
	fi

	# --------------------------------------------------------------------------
	# SAVE REAL UID AND POLICY ON FILE (UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC)
	# --------------------------------------------------------------------------
	FILE_UID=$DIR_REQ/$8.uid

	if [ -z "$WA_UID" ]; then
		WA_UID=$8
	fi

	write_FILE "$WA_UID $POLICY $MAX_TIME $MAX_TRAFFIC" $FILE_UID
	# --------------------------------------------------------------------

	FILE_CNT=$DIR_CNT/$POLICY/$8
	# --------------------------------------------------------------------
	# TIME POLICY
	# --------------------------------------------------------------------
	if [ -z "$MAX_TIME" ]; then
		MAX_TIME=0
	fi

	if [ $MAX_TIME -gt 0 ]; then
		# --------------------------------------------------------------------
		# WE CHECK FOR THE TIME REMAIN FOR CONNECTION (SECS) SAVED ON FILE
		# --------------------------------------------------------------------
		REMAIN=$FILE_CNT.timeout

		if [ ! -s $REMAIN ]; then
			TIMEOUT=$MAX_TIME
			# ---------------------------------------------------------
			# we save the time remain for connection (secs) on file
			# ---------------------------------------------------------
			write_FILE $TIMEOUT $FILE_CNT.timeout
			# ---------------------------------------------------------
		else
			read TIMEOUT < $REMAIN

			if [ $TIMEOUT -eq 0 ]; then
				message_page "Tempo consumato" "Hai consumato il tempo disponibile del servizio!"
			fi
		fi
		# --------------------------------------------------------------------
	fi
	# --------------------------------------------------------------------

	# --------------------------------------------------------------------
	# TRAFFIC POLICY
	# --------------------------------------------------------------------
	if [ -z "$MAX_TRAFFIC" ]; then
		MAX_TRAFFIC=0
	fi

	if [ $MAX_TRAFFIC -gt 0 ]; then
		# --------------------------------------------------------------------
		# WE CHECK FOR THE TRAFFIC REMAIN FOR CONNECTION (BYTES) SAVED ON FILE
		# --------------------------------------------------------------------
		REMAIN=$FILE_CNT.traffic

		if [ ! -s $REMAIN ]; then
			TRAFFIC=$MAX_TRAFFIC
			# ---------------------------------------------------------
			# we save the remain traffic for connection (bytes) on file
			# ---------------------------------------------------------
			write_FILE $TRAFFIC $FILE_CNT.traffic
			# ---------------------------------------------------------
		else
			read TRAFFIC < $REMAIN

			if [ $TRAFFIC -eq 0 ]; then
				message_page "Traffico consumato" "Hai consumato il traffico disponibile del servizio!"
			fi
		fi
		# --------------------------------------------------------------------
	fi
	# --------------------------------------------------------------------

	if [ -z "$REDIRECT_DEFAULT" ]; then
		REDIRECT_DEFAULT=$3
	fi

	SIGNED_DATA="
Action   Permit
Mode	   Login
Redirect	$PROT://$SERVER/postlogin?uid=$8&gateway=$4&redirect=$REDIRECT_DEFAULT&ap=$7&ip=$2&mac=$1&timeout=$TIMEOUT&traffic=$TRAFFIC
Mac		$1
Timeout	$TIMEOUT
Traffic	$TRAFFIC
Token		$6
User		$8"

	sign_data

	write_to_LOG "$8" "$7" "$2" "$1" "$TIMEOUT" "$TRAFFIC"

	if [ -n "$UUID_TO_APPEND" ]; then
		append_to_FILE " $8" $REQ_FILE # si aggiunge UUID alla request...
	fi

	echo -e "Location: http://$4/?ticket=$SIGNED_DATA\r\n\r"

	exit 0
}

get_timeout_secs() {

	DSTART=`printf "%4s-%2s-%2s %2s:%2s:%2s" ${1:0:4} ${1:4:2} ${1:6:2} ${1:8:2} ${1:10:2} ${1:12:2} 2>/dev/null`
	  DEND=`printf "%4s-%2s-%2s %2s:%2s:%2s" ${2:0:4} ${2:4:2} ${2:6:2} ${2:8:2} ${2:10:2} ${2:12:2} 2>/dev/null`

	START=`date --date="$DSTART" +%s 2>/dev/null`
	  END=`date --date="$DEND"   +%s 2>/dev/null`

	let "TIMEOUT = $END - $START"
}

auth_check_card() {

	# $1	-> mac
	# $2  -> ip
	# $3	-> redirect
	# $4	-> gateway
	# $5	-> timeout
	# $6	-> token
	# $7	-> ap
	# $8	-> domain (es: 10_piazze, paas)
	# $9	-> uid
	# $10	-> pass
	# $11 -> button

	# Ex: 00:15:58:0c:9e:26 10.30.1.102 http://ap1 10.30.1.112:5280 86400 10.30.1.102&1255107570&42cb373714c ap0.rs paas 3397363258 pswd Entra

	OP=PASS_AUTH

	# ---------------------------------------------------
	# TEST (bypass LDAP)
	# ---------------------------------------------------
	#TEST=1

	if [ "$TEST" = "1" ]; then
		load_policy
	else
	# ---------------------------------------------------

#	set -x

	if [ -z "$9" -o -z "${10}" ]; then
		message_page "Impostare utente e password" "Impostare utente e password"
	fi

	# Check 1: Wrong user and/or password

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_CARD_BASEDN $LDAP_CARD_PARAM" "(&(waLogin=$9)(waPassword=${10}))"

	if [ -z "$OUTPUT" ]; then
		message_page "Utente e/o Password errato/i" "Credenziali errate!"
	fi

	# --------------------------------------------------------------------
	# GET USER FOR THIS CARD
	# --------------------------------------------------------------------
	WA_UID=`echo "$OUTPUT" | grep 'waUsedBy: ' | cut -f2 -d' ' 2>/dev/null`

	# Check 2: Activation required

	if [ -z "$WA_UID" ]; then
		message_page "Attivazione non effettuata" "Per utilizzare il servizio e' richiesta l'attivazione"
	fi
	# --------------------------------------------------------------------

	# Check 3: Card revoked

	REVOKED=`echo "$OUTPUT" | grep 'waRevoked: ' | cut -f2 -d' ' 2>/dev/null`

	if [ "$REVOKED" != FALSE ]; then
		message_page "Carta revocata" "La tua carta e' revocata!"
	fi

	# --------------------------------------------------------------------
	# GET POLICY FOR THIS CARD
	# --------------------------------------------------------------------
	WA_POLICY=`echo "$OUTPUT" | grep 'waPolicy: ' | cut -f2 -d' ' 2>/dev/null`

	if [ -n "$WA_POLICY" ]; then
		POLICY=$WA_POLICY
	fi

	load_policy

	WA_TIME=`echo "$OUTPUT"		| grep 'waTime: '		| cut -f2 -d' ' 2>/dev/null`
	WA_TRAFFIC=`echo "$OUTPUT" | grep 'waTraffic: ' | cut -f2 -d' ' 2>/dev/null`

	if [ -n "$WA_TIME" ]; then
		MAX_TIME=$WA_TIME
	fi

	if [ -n "$WA_TRAFFIC" ]; then
		MAX_TRAFFIC=$WA_TRAFFIC
	fi
	# --------------------------------------------------------------------

	if [ $NOTAFTER_CHECK -eq 1 ]; then

		GEN_TIME=`date +%Y%m%d%H%M%SZ` # GeneralizedTime YYYYmmddHH[MM[SS]][(./,)d...](Z|(+/-)HH[MM])

		# Check 4: Expired validity

		NOT_AFTER=`echo "$OUTPUT" | grep 'waNotAfter: ' | cut -f2 -d' ' 2>/dev/null`

		if [ -n "$NOT_AFTER" ]; then

			get_timeout_secs "$GEN_TIME" "$NOT_AFTER"

			if [ $TIMEOUT -lt 0 ]; then
				message_page "Validita' scaduta" "La tua validita' e' scaduta!"
			fi

		else

			OP=FIRST_PASS_AUTH

			# Update card with a new generated waNotAfter

			DN=`		  echo "$OUTPUT" | grep 'dn: '			| cut -f2 -d' ' 2>/dev/null`
			VALIDITY=` echo "$OUTPUT" | grep 'waValidity: ' | cut -f2 -d' ' 2>/dev/null`

			let "TIMEOUT = $VALIDITY * 86400"

			NOT_AFTER=`date --date="+$VALIDITY days" +%Y%m%d%H%M%SZ 2>/dev/null`

			ask_to_LDAP ldapmodify "-c $LDAP_CARD_PARAM" "
dn: $DN
changetype: modify
add: waNotAfter
waNotAfter: $NOT_AFTER
"
		fi
	fi

	# ---------------------------------------------------
	# TEST (bypass LDAP)
	# ---------------------------------------------------
	fi
	# ---------------------------------------------------

	# redirect back to the gateway appending a signed ticket that will signal NoDog to unlock the firewall...

	send_ticket "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$9"
}

request_to_logout_from_user() {

# 	set -x

	# NoDog data saved on file
	# ------------------------
	# $1 -> ap
	# $2 -> gateway
	# $3 -> mac
	# $4 -> ip
	# $5 -> redirect
	# $6 -> timeout
	# $7 -> token

	unset BACK_TAG

	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	if [ ! -s $REQ_FILE ]; then
		message_page "ID di sessione mancante" "Utente non connesso (session id: $SESSION_ID)"
	fi

	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773

	read AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID < $REQ_FILE

	if [ -n "$UUID" -a -s $DIR_CTX/$UUID.ctx ]; then

		# --------------------------------------------------------------------
		# GET POLICY FROM FILE (UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC)
		# --------------------------------------------------------------------
		FILE_UID=$DIR_REQ/$UUID.uid

		read UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC < $FILE_UID

		load_policy
		# --------------------------------------------------------------------

		ask_nodog_to_logout_user

		PARAM=""

		BASE_NAME=ringraziamenti

		if [ -s $DIR_CNT/$POLICY/$UUID.timeout -o \
			  -s $DIR_CNT/$POLICY/$UUID.traffic ]; then

			PARAM="<table class=\"centered\" border=\"1\">
					<tr>
						<th class=\"header\" colspan=\"2\" align=\"left\">Utente&nbsp;&nbsp;&nbsp;$UUID</th>
					</tr>"

			if [ -s $DIR_CNT/$POLICY/$UUID.timeout ]; then

				REMAINING_TIME=`cat $DIR_CNT/$POLICY/$UUID.timeout`

				# expressing the time in minutes
				REMAINING_TIME_MIN=`expr $REMAINING_TIME / 60`

				PARAM="$PARAM
					<tr>
						<td class=\"header\">Tempo residuo (min.)</td>
						<td class=\"data_italic\">$REMAINING_TIME_MIN</td>
					</tr>"
			fi

			if [ -s $DIR_CNT/$POLICY/$UUID.traffic ]; then

				REMAINING_TRAFFIC=`cat $DIR_CNT/$POLICY/$UUID.traffic`

				# expressing the traffic in MB 1024*1024=1048576
				REMAINING_TRAFFIC_MB=`expr $REMAINING_TRAFFIC / 1048576`

				PARAM="$PARAM
					<tr>
						<td class=\"header\">Traffico residuo (MB)</td>
						<td class=\"data_italic\">$REMAINING_TRAFFIC_MB</td>
					</tr>"
			fi

			PARAM="$PARAM
					</table>"

		fi

		print_page "$PARAM"

	else
		message_page "Utente non connesso" "Utente non connesso"
	fi

#	set +x
}

info_notified_from_nodog() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> gateway
	# $4 -> ap
	# $5 -> uid
	# $6 -> logout
	# $7 -> connected
	# $8 -> traffic

# 	set -x

	OP=LOGOUT

	unset LOGOUT

	append_to_FILE "`_date` op: INFO uid: $5, ap: $4, ip: $2, mac: $1, logout: $6, connected: $7, traffic: $8" $FILE_LOG.info

	check_for_user_already_connected "$1" "$2" "$3" "$4" "$5"

	# NB: FILE_CTX e' settato da get_user_context_connection() che e' chiamato da check_for_user_already_connected()...

	if [ -z "$FILE_CTX" -o "$OP" = "RENEW" ]; then

		IP=$2
		MAC=$1
		GATEWAY=$3

		if [ "$OP" = "RENEW" ]; then
			anomalia 7
		else
			save_connection_context $4 $5 $3 $1 $2 # save connection context data on file (ap uuid gateway mac ip) to avoid another anomalia...

			anomalia 6
		fi

	elif [ $6 -ne 0 ]; then # logout

		LOGOUT=true

		# we remove the connection context data saved on file and NoDog data saved on file
		rm -f $FILE_CTX $DIR_REQ/$2.req

	fi

	# --------------------------------------------------------------------
	# GET POLICY FROM FILE (UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC)
	# --------------------------------------------------------------------
	FILE_UID=$DIR_REQ/$5.uid

	read UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC < $FILE_UID

	load_policy
	# --------------------------------------------------------------------

	FILE_CNT=$DIR_CNT/$POLICY/$5
	# --------------------------------------------------------------------
	# TRAFFIC POLICY
	# --------------------------------------------------------------------
	if [ -z "$MAX_TRAFFIC" ]; then
		MAX_TRAFFIC=0
	fi

	if [ $MAX_TRAFFIC -gt 0 ]; then
		# --------------------------------------------------------------------
		# WE CHECK FOR THE TRAFFIC REMAIN FOR CONNECTION (BYTES) SAVED ON FILE
		# --------------------------------------------------------------------
		TRAFFIC=0

		if [ -s $FILE_CNT.traffic ]; then
			read TRAFFIC < $FILE_CNT.traffic

			let "TRAFFIC = TRAFFIC - $8"

			if [ $TRAFFIC -lt 0 ]; then
				TRAFFIC=0
			fi
		fi
		# ---------------------------------------------------------
		# we save the remain traffic for connection (bytes) on file
		# ---------------------------------------------------------
		write_FILE $TRAFFIC $FILE_CNT.traffic

		if [ $TRAFFIC -eq 0 -a -z "$LOGOUT" ]; then

			LOGOUT=true

			ask_nodog_to_logout_user

		fi
		# ---------------------------------------------------------
	fi
	# ---------------------------------------------------------

	# --------------------------------------------------------------------
	# TIME POLICY
	# --------------------------------------------------------------------
	if [ -z "$MAX_TIME" ]; then
		MAX_TIME=0
	fi

	if [ $MAX_TIME -gt 0 ]; then
		# --------------------------------------------------------------------
		# WE CHECK FOR THE TIME REMAIN FOR CONNECTION (SECS) SAVED ON FILE
		# --------------------------------------------------------------------
		TIMEOUT=0

		if [ -s $FILE_CNT.timeout ]; then
			read TIMEOUT < $FILE_CNT.timeout

			let "TIMEOUT = TIMEOUT - $7"

			if [ $TIMEOUT -lt 0 ]; then
				TIMEOUT=0
			fi
		fi
		# ---------------------------------------------------------
		# we save the time remain for connection (secs) on file
		# ---------------------------------------------------------
		write_FILE $TIMEOUT $FILE_CNT.timeout

		if [ $TIMEOUT -eq 0 -a -z "$LOGOUT" ]; then

			LOGOUT=true

			ask_nodog_to_logout_user

		fi
		# ---------------------------------------------------------
	fi
	# ---------------------------------------------------------

	if [ $6 -eq -1 ]; then # disconneted (logout implicito)

		OP=EXIT

		if [ $MAX_TRAFFIC -gt 0 -a $TRAFFIC -gt 0 ]; then

			# bonus

			let "TIMEOUT = TIMEOUT + $BONUS_FOR_EXIT"

			write_FILE $TIMEOUT $FILE_CNT.timeout

		fi

	fi

	if [ $6 -ne 0 ]; then # logout

		write_to_LOG "$5" "$4" "$2" "$1" "$TIMEOUT" "$TRAFFIC"

		# we remove the data saved on file
		rm -f $DIR_REQ/$5.uid

	fi

	if [ $# -gt 8 ]; then

		shift 8

		info_notified_from_nodog "$@"

	elif [ -n "$LOGOUT" ]; then

		OUTPUT="<html><body>LOGOUT</body></html>"

	else

		OUTPUT="<html><body>OK</body></html>"

	fi

# 	set +x
}

ask_nodog_to_check_for_users_info() {

#	set -x

	# we request nodog to check for users logout or disconnect...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	FILE_TMP=/tmp/nodog.check.$$

	send_request_to_nodog "http://$GATEWAY/check" $FILE_TMP "-i"

	if [ -s $FILE_TMP ]; then

		read HTTP_VERSION HTTP_STATUS HTTP_DESCR < $FILE_TMP

		if [ "$HTTP_STATUS" = "204" ]; then # 204 - HTTP_NO_CONTENT

			sleep 9

			ask_nodog_to_check_for_users_info

		fi

		rm -f $FILE_TMP
	fi

#	set +x
}

get_users_info() {

#	set -x

	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# cat $DIR_REQ/*.req 2>/dev/null | cut -f 1-2 -d' ' | uniq >/tmp/ACCESS_POINT.lst 2>/dev/null
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# ACCESS_POINT_LIST=$WIFI_PORTAL_HOME/etc/ACCESS_POINT.lst
	# ------------------------------------------------------------------------------------------------------------------------------------------------

	NUM_ACCESS_POINT=`wc -l < $ACCESS_POINT_LIST 2>/dev/null`

	if [ $NUM_ACCESS_POINT -gt 0 ]; then

		while read AP GATEWAY
		do

			ask_nodog_to_check_for_users_info # we request nodog to check for users logout or disconnect...

		done < $ACCESS_POINT_LIST

	fi

	OUTPUT="<html><body>OK</body></html>"
}

info_start_ap() {

#	set -x

	# $1 -> ap

	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# *.req (AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID)
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105 http://www.google.com 0 10.30.1.105&1257603166&2a2436611f452f8eebddce4992e88f8d 055340773
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# *.cxt (AP UUID GATEWAY MAC IP)
	# ------------------------------------------------------------------------------------------------------------------------------------------------
	# stefano 055340773 10.30.1.131:5280 00:e0:4c:d4:63:f5 10.30.1.105
	# ------------------------------------------------------------------------------------------------------------------------------------------------

	LIST=`grep -l "^$1 " $DIR_REQ/*.req $DIR_REQ/*.uid $DIR_CTX/*.ctx 2>/dev/null`

	if [ -n "$LIST" ]; then

		OP=QUIT
		LIST_SAFE=""

		for FILE in $LIST
		do
			unset GATEWAY

			SUFFIX="${FILE##*.}"

			if [ "$SUFFIX" = "req" ]; then

				read AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID < $FILE

			elif [ "$SUFFIX" = "ctx" ]; then

				read AP UUID GATEWAY MAC IP < $FILE

			fi

			if [ "$AP" = "$1" -a "$GATEWAY" = "${REMOTE_ADDR}:5280" ]; then

				LIST_SAFE="$FILE $LIST_SAFE"

				if [ "$SUFFIX" = "ctx" ]; then

					write_to_LOG "$UUID" "$AP" "$IP" "$MAC" "$TIMEOUT" "$TRAFFIC"

				fi

			fi

		done

		rm -f $LIST_SAFE

	fi

	OUTPUT="<html><body>OK</body></html>"

#	set +x
}

upload_log_ap() {

# 	set -x

	# -----------------------------------------
	# $1 -> path file upload
	# -----------------------------------------

   mv $1 $HISTORICAL_LOG_DIR

	OUTPUT="<html><body>OK</body></html>"

# 	set +x
}

load_value_session() {

#	set -x

	if [ -s $TMP_FORM_FILE ]; then

		i=1
		while read LINE
		do
			eval v$i=\"$LINE\"

			let "i = i + 1"
		done < $TMP_FORM_FILE

	fi

#	set +x
}

get_user_nome_cognome() {

#	set -x

	TMP_FORM_FILE=$DIR_REG/$UUID.reg

	load_value_session

	if [ -n "$v1$v2" ]; then
		USER="$v1 $v2"
	else
		USER=$UUID
	fi

#	set +x
}

get_stato_utente() {

#	set -x

	get_user_context_connection

	if [ -z "$GATEWAY" ]; then
		message_page "Utente non connesso" "Utente non connesso"
	else

		get_user_nome_cognome

		ask_nodog_status_user

		printf "`cat $FORM_FILE_DIR/${BASE_NAME}.tmpl 2>/dev/null`" "`date`" $AP "$USER" "$OUTPUT" "$BACK_TAG" > $DIR_STAT/$UUID.html 2>/dev/null

		echo -e "Location: /wi-auth/stat/$UUID.html\r\n\r"

	fi

	exit 0
}

# more environment...
if [ -n "$FILE_TO_SOURCE" ]; then
   . $FILE_TO_SOURCE
fi

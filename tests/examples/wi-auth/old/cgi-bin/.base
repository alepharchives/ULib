#!/bin/bash

# .base

uscita() {

	if [ -s $TMPFILE.out ]; then
		rm -f $TMPFILE.out
	fi
	if [ -s $TMPFILE.err ]; then
		rm -f $TMPFILE.err
	fi

	exit $EXIT_VALUE
}

print_page() {

	OUTPUT=`cat $FORM_FILE_DIR/$BASE_NAME.tmpl 2>/dev/null`

	if [ $# -ne 0 ]; then
		OUTPUT=`printf "$OUTPUT" "$@" 2>/dev/null`
	fi
}

write_OUTPUT() {

	if [ -n "$OUTPUT" ]; then

		if [ -n "$CONNECTION_CLOSE" ]; then
			echo -e "Connection: close\r"
		fi

		if [ -n "$SET_COOKIE" ]; then
			# REQ: Set-Cookie: TODO[ data expire path domain secure HttpOnly ]
			# ----------------------------------------------------------------------------------------------------------------------------
			# string -- Data to put into the cookie         -- must
			# int    -- Lifetime of the cookie in HOURS     -- must (0 -> valid until browser exit)
			# string -- Path where the cookie can be used   --  opt
			# string -- Domain which can read the cookie    --  opt
			# bool   -- Secure mode                         --  opt
			# bool   -- Only allow HTTP usage               --  opt
			# ----------------------------------------------------------------------------------------------------------------------------
			# RET: Set-Cookie: ulib_sid=data&expire&HMAC-MD5(data&expire); expires=expire(GMT); path=path; domain=domain; secure; HttpOnly

			echo -e "Set-Cookie: TODO[ $SET_COOKIE 4320 ]\r" # 180 days
		fi

		echo -e "Content-Type: text/html; charset=utf-8\r\n\r"
		echo -n -E "$OUTPUT"

	else
		# BAD REQUEST
		echo -e "Status: 400\r\n\r\n" \
				  "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n" \
				  "<html><head>\r\n" \
				  "<title>400 Bad Request</title>\r\n" \
				  "</head><body>\r\n" \
				  "<h1>Bad Request</h1>\r\n" \
				  "<p>Your browser sent a request that this server could not understand.<br />\r\n" \
				  "</p>\r\n" \
				  "<hr>\r\n" \
				  "<address>ULib Server</address>\r\n" \
				  "</body></html>\r"

		EXIT_VALUE=1
	fi

	uscita
}

ANOMALIA_page() {

	BASE_NAME=ANOMALIA_page

	print_page "$@"

	write_OUTPUT
}

anomalia() {

	# ---------------------------------------------
	# $1 -> exit value
	# ---------------------------------------------
	#  2 write_FILE
	#  3 append_to_FILE
	#  4 sign_data
	#  5 send_request_to_nodog (curl | uclient)
	#  6 info_notified_from_nodog (missing ctx)
	#  7 info_notified_from_nodog (RENEW)
	#  8 ask_to_LDAP
	#  9 login request (req without ctx)
	# 10 load_policy (policy without file)
	# ---------------------------------------------

	EXIT_VALUE=$1

	MSG=`printf "$MSG_ANOMALIA" 00$1`

	case "$1" in
	10)
		MSG=`printf "$BASE_NAME: load_policy() failure (anomalia 010)" POLICY=\"$POLICY\"`

		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $MSG"

		MSG=`printf "Servizio non disponibile (anomalia %s). Contattare l'assistenza." 00$1`

		message_page "Servizio non disponibile" "$MSG"
	;;
	9)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: login request failure (anomalia 009)"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"
	;;
	8)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: Servizio LDAP non disponibile (anomalia 008)"

		if [ -n "$ADMIN_CONTEXT" ]; then
			MSG=`printf "Servizio LDAP non disponibile (anomalia %s). Contattare l'assistenza." 00$1`
		else
			BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		fi

		message_page "Servizio LDAP non disponibile" "$MSG"
	;;
	7 | 6)
		MSG=`printf "$BASE_NAME: info_notified_from_nodog() failure (anomalia %s)" 00$1 file_ctx=\"$FILE_CTX\"`

		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $MSG"

		ask_nodog_to_logout_user

		return
	;;
	5)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: send_request_to_nodog() failure (anomalia 005) gateway=$GATEWAY"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"

		return
	;;
	4)
		logger -p $LOCAL_SYSLOG_SELECTOR "$PORTAL_NAME: $BASE_NAME: sign_data() failure (anomalia 004)"

		BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"
		message_page "Servizio non disponibile" "$MSG"
	;;
	*)
		chmod 777 $WIFI_PORTAL_HOME/ANOMALIA

		ANOMALIA_page
	;;
	esac

	uscita
}

write_FILE() {

	# $1 -> data
	# $2 -> filename
	# $3 -> option

	echo $3 "$1" > $2

	if [ $? -ne 0 ]; then
		anomalia 2
	fi
}

append_to_FILE() {

	# $1 -> data
	# $2 -> filename

	echo "$1" >> $2

	if [ $? -ne 0 ]; then
		anomalia 3
	fi
}

_date() { date '+%Y/%m/%d %H:%M:%S' ; }

write_to_LOG() {

	# $1 -> uid
	# $2 -> ap
	# $3 -> ip
	# $4 -> mac
	# $5 -> timeout
	# $6 -> traffic

	# --------------------------------------------------------------------
	# GET REAL UID FROM FILE (UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC)
	# --------------------------------------------------------------------
	FILE_UID=$DIR_REQ/$1.uid

	read UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC < $FILE_UID

	if [ -z "$UUID_TO_LOG" ]; then
		UUID_TO_LOG=$1
	fi
	# --------------------------------------------------------------------

	RIGA="`_date` op: $OP, uid: $UUID_TO_LOG, ap: $2, ip: $3, mac: $4, timeout: $5, traffic: $6 policy: $POLICY"

	append_to_FILE "$RIGA" $FILE_LOG

	sync

	logger -p $REMOTE_SYSLOG_SELECTOR "$PORTAL_NAME: $RIGA"
}

send_request_to_nodog() {

	# $1 -> url
	# $2 -> filename to save output
	# $3 -> option

	# we send request to nodog...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	# UTRACE="0 10M 0"
	# UOBJDUMP="0 100k 10"
	# USIMERR="error.sim"
	export UTRACE UOBJDUMP USIMERR

	OUTPUT=`$CLIENT_HTTP $3 "$1" 2>>/tmp/CLIENT_HTTP.err`

	if [ $? -ne 0 ]; then
		anomalia 5
	fi

	if [ -n "$2" -a -n "$OUTPUT" ]; then

		write_FILE "$OUTPUT" $2

		unset OUTPUT

	fi
}


ask_to_LDAP() {

#	set -x

	# $1 -> cmd
	# $2 -> param
	# $3 -> option
	# $4 -> filter_option

	TMPFILE=/tmp/ask_to_LDAP.$$

	if [ "$1" = ldapsearch ]; then
		ldapsearch $2 "$3" $4 >$TMPFILE.out 2>$TMPFILE.err
	else
				  $1 $2 <<END   >$TMPFILE.out 2>$TMPFILE.err
$3
END
	fi

	EXIT_VALUE=$?

	if [ $EXIT_VALUE -eq 0 ]; then

		rm -f $TMPFILE.err

	elif [ -s $TMPFILE.err ]; then

		rm -f $TMPFILE.out

		grep '(-1)' < $TMPFILE.err # Can't contact LDAP server (-1)

		if [ $? -eq 0 ]; then
			anomalia 8
		fi

	fi

#	set +x
}

message_page() {

	BASE_NAME=message_page

	print_page "$@" "$BACK_TAG"

	write_OUTPUT
}

load_policy() {

#	set -x

	if [ -z "$POLICY" ]; then
		POLICY=default
	fi

	POLICY_FILE=$DIR_POLICY/$POLICY

	if [ ! -s $POLICY_FILE ]; then
		anomalia 10
	fi

	source $DIR_POLICY/$POLICY

 	mkdir -p $DIR_CNT/$POLICY

#	set +x
}

save_connection_request() {

	# $1 -> data

	# ---------------------------------------------------------------------------------
	# SAVE REQUEST CONTEXT DATA ON FILE (AP GATEWAY MAC IP REDIRECT TIMEOUT TOKEN UUID)
	# ---------------------------------------------------------------------------------
	REQ_FILE=$DIR_REQ/$SESSION_ID.req

	write_FILE "$1" $DIR_REQ/$SESSION_ID.req "-n"
	# ---------------------------------------------------------------------------------
}

save_connection_context() {

	# $1 -> ap
	# $2 -> uid
	# $3 -> gateway
	# $4 -> mac
	# $5 -> ip

	# --------------------------------------------------------------------
	# SAVE CONNECTION CONTEXT DATA ON FILE (AP UUID GATEWAY MAC IP)
	# --------------------------------------------------------------------
	FILE_CTX=$DIR_CTX/$2.ctx

	write_FILE "$1 $2 $3 $4 $5" $FILE_CTX
	# --------------------------------------------------------------------
}

get_user_context_connection() {

	# $1 -> uid

	if [ $# -eq 1 ]; then
		FILE_CTX=$DIR_CTX/$1.ctx
	else
		FILE_CTX=`grep -l $REMOTE_ADDR $DIR_CTX/*.ctx 2>/dev/null`
	fi

	# data connection context saved on file
	# -------------------------------------
	# ap uid gateway mac ip

	if [ -n "$FILE_CTX" -a -s "$FILE_CTX" ]; then
		read AP UUID GATEWAY MAC IP < $FILE_CTX
	else
		unset FILE_CTX AP UUID GATEWAY MAC IP
	fi
}

check_for_user_already_connected() {

# 	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> gateway
	# $4 -> ap
	# $5 -> uid

	get_user_context_connection $5

	if [ -n "$FILE_CTX" ]; then

		if [ "$MAC"		 != "$1" -o \
			  "$IP"		 != "$2" -o \
			  "$GATEWAY" != "$3" -o \
			  "$AP"		 != "$4" ]; then

			OP=RENEW

		fi

	fi

# 	set +x
}

user_has_valid_MAC() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap

	# List of allowed MAC

	FILE=$DIR_CTX/.MAC_WHITE_LIST

	if [ -s $FILE ]; then

		load_policy

		while read MAC
		do

			if [ "$MAC" = "$1" ]; then

				# NoDog is calling for auth, redirect back to the gateway appending a signed ticket that will signal NoDog to unlock the firewall...

				OP=MAC_AUTH

				send_ticket "$@" "$MAC" 

			fi

		done < $FILE

	fi
}

user_has_valid_cert() {

 	ask_to_LDAP ldapsearch "-LLL -b $WIAUTH_USER_BASEDN $LDAP_USER_PARAM" \
			"(&(objectClass=waUser)(&(waIssuer=$SSL_CLIENT_I_DN)(waSerial=$SSL_CLIENT_CERT_SERIAL)(waActive=TRUE)))"

	if [ -s $TMPFILE.out ]; then

		USER=`cat $TMPFILE.out | grep 'waUid: ' | cut -f2 -d' ' 2>/dev/null`

		if [ -z "$USER" ]; then
			USER=unknow
		fi

		# NoDog is calling for auth, redirect back to the gateway appending a signed ticket that will signal NoDog to unlock the firewall...

		OP=CERT_AUTH

		send_ticket "$@" "$USER"

	fi
}

login_with_problem() {

	BACK_TAG="<a class=\"back\" href=\"$REDIRECT_DEFAULT\">RIPROVA</a>"

	message_page "Login" "Problema in fase di autenticazione. Si prega di riprovare, se il problema persiste contattare: $TELEFONO"
}

ask_nodog_status_user() {

#	set -x

	# we request the status of the indicated user...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	send_request_to_nodog "http://$GATEWAY/status?ip=$REMOTE_ADDR"

#	set +x
}

ask_nodog_to_logout_user() {

#	set -x

	# we request to logout this user with the old ip from the associated gateway...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	SIGNED_DATA="ip=$IP&mac=$MAC"

	sign_data

	send_request_to_nodog "http://$GATEWAY/logout?$SIGNED_DATA"

#	set +x
}

sign_data() {

#	set -x

	SIGNED_DATA=`echo -n -E "$SIGNED_DATA" | openssl des3 -pass pass:200912281747 -a -e | tr -d '\n'`

#	set +x
}

send_ticket() {

#	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap
	# $8 -> uid

	# -------------------------------------------------------------
	# CHECK FOR CHANGE OF CONNECTION CONTEXT FOR SAME USER ID
	# -------------------------------------------------------------
	check_for_user_already_connected "$1" "$2" "$4" "$7" "$8"

	if [ "$OP" = "RENEW" ]; then
		ask_nodog_to_logout_user
	fi

	# --------------------------------------------------------------------------
	# SAVE REAL UID AND POLICY ON FILE (UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC)
	# --------------------------------------------------------------------------
	FILE_UID=$DIR_REQ/$8.uid

	if [ -z "$WA_UID" ]; then
		WA_UID=$8
	fi

	write_FILE "$WA_UID $POLICY $MAX_TIME $MAX_TRAFFIC" $FILE_UID
	# --------------------------------------------------------------------

	FILE_CNT=$DIR_CNT/$POLICY/$WA_UID
	# --------------------------------------------------------------------
	# TIME POLICY
	# --------------------------------------------------------------------
	if [ -z "$MAX_TIME" ]; then
		MAX_TIME=0
	fi

	if [ $MAX_TIME -gt 0 ]; then
		# --------------------------------------------------------------------
		# WE CHECK FOR THE TIME REMAIN FOR CONNECTION (SECS) SAVED ON FILE
		# --------------------------------------------------------------------
		REMAIN=$FILE_CNT.timeout

		if [ ! -s $REMAIN ]; then
			TIMEOUT=$MAX_TIME
			# ---------------------------------------------------------
			# we save the time remain for connection (secs) on file
			# ---------------------------------------------------------
			write_FILE $TIMEOUT $FILE_CNT.timeout
			# ---------------------------------------------------------
		else
			read TIMEOUT < $REMAIN

			if [ $TIMEOUT -eq 0 ]; then
				message_page "Tempo consumato" "Hai consumato il tempo disponibile del servizio!"
			fi
		fi
		# --------------------------------------------------------------------
	fi
	# --------------------------------------------------------------------

	# --------------------------------------------------------------------
	# TRAFFIC POLICY
	# --------------------------------------------------------------------
	if [ -z "$MAX_TRAFFIC" ]; then
		MAX_TRAFFIC=0
	fi

	if [ $MAX_TRAFFIC -gt 0 ]; then
		# --------------------------------------------------------------------
		# WE CHECK FOR THE TRAFFIC REMAIN FOR CONNECTION (BYTES) SAVED ON FILE
		# --------------------------------------------------------------------
		REMAIN=$FILE_CNT.traffic

		if [ ! -s $REMAIN ]; then
			TRAFFIC=$MAX_TRAFFIC
			# ---------------------------------------------------------
			# we save the remain traffic for connection (bytes) on file
			# ---------------------------------------------------------
			write_FILE $TRAFFIC $FILE_CNT.traffic
			# ---------------------------------------------------------
		else
			read TRAFFIC < $REMAIN

			if [ $TRAFFIC -eq 0 ]; then
				message_page "Traffico consumato" "Hai consumato il traffico disponibile del servizio!"
			fi
		fi
		# --------------------------------------------------------------------
	fi
	# --------------------------------------------------------------------

	if [ -z "$REDIRECT_DEFAULT" ]; then
		REDIRECT_DEFAULT=$3
	fi

	SIGNED_DATA="
Action   Permit
Mode	   Login
Redirect	http://$HTTP_HOST/postlogin?uid=$8&gateway=$4&redirect=$REDIRECT_DEFAULT&ap=$7&ip=$2&mac=$1&timeout=$TIMEOUT&traffic=$TRAFFIC
Mac		$1
Timeout	$TIMEOUT
Traffic	$TRAFFIC
Token		$6
User		$8"

	sign_data

	write_to_LOG "$8" "$7" "$2" "$1" "$TIMEOUT" "$TRAFFIC"

	if [ -n "$UUID_TO_APPEND" ]; then
		append_to_FILE " $8" $REQ_FILE # si aggiunge UUID alla request...
	fi

	echo -e "Location: http://$4/$URI_TICKET?ticket=$SIGNED_DATA\r\n\r"

	uscita
}

get_timeout_secs() {

	DSTART=`printf "%4s-%2s-%2s %2s:%2s:%2s" ${1:0:4} ${1:4:2} ${1:6:2} ${1:8:2} ${1:10:2} ${1:12:2} 2>/dev/null`
	  DEND=`printf "%4s-%2s-%2s %2s:%2s:%2s" ${2:0:4} ${2:4:2} ${2:6:2} ${2:8:2} ${2:10:2} ${2:12:2} 2>/dev/null`

	START=`date --date="$DSTART" +%s 2>/dev/null`
	  END=`date --date="$DEND"   +%s 2>/dev/null`

	let "TIMEOUT = $END - $START"
}

info_notified_from_nodog() {

	# $1 -> mac
	# $2 -> ip
	# $3 -> gateway
	# $4 -> ap
	# $5 -> uid
	# $6 -> logout
	# $7 -> connected
	# $8 -> traffic

# 	set -x

	OP=LOGOUT

	unset LOGOUT

	append_to_FILE "`_date` op: INFO uid: $5, ap: $4, ip: $2, mac: $1, logout: $6, connected: $7, traffic: $8" $FILE_LOG.info

	# --------------------------------------------------------------------
	# GET POLICY FROM FILE (UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC)
	# --------------------------------------------------------------------
	FILE_UID=$DIR_REQ/$5.uid

	read UUID_TO_LOG POLICY MAX_TIME MAX_TRAFFIC < $FILE_UID

	load_policy
	# --------------------------------------------------------------------

	check_for_user_already_connected "$1" "$2" "$3" "$4" "$5"

	# NB: FILE_CTX e' settato da get_user_context_connection() che e' chiamato da check_for_user_already_connected()...

	if [ -z "$FILE_CTX" -o "$OP" = "RENEW" ]; then

		IP=$2
		MAC=$1
		GATEWAY=$3

		if [ "$OP" = "RENEW" ]; then
			anomalia 7
		else
			save_connection_context $4 $5 $3 $1 $2 # save connection context data on file (ap uuid gateway mac ip) to avoid another anomalia...

			anomalia 6
		fi

	elif [ $6 -ne 0 ]; then # logout

		LOGOUT=true

		# we remove the connection context data saved on file and NoDog data saved on file
		rm -f $FILE_CTX $DIR_REQ/$2.req
	fi

	FILE_CNT=$DIR_CNT/$POLICY/$UUID_TO_LOG
	# --------------------------------------------------------------------
	# TRAFFIC POLICY
	# --------------------------------------------------------------------
	if [ -z "$MAX_TRAFFIC" ]; then
		MAX_TRAFFIC=0
	fi

	if [ $MAX_TRAFFIC -gt 0 ]; then
		# --------------------------------------------------------------------
		# WE CHECK FOR THE TRAFFIC REMAIN FOR CONNECTION (BYTES) SAVED ON FILE
		# --------------------------------------------------------------------
		TRAFFIC=0

		if [ -s $FILE_CNT.traffic ]; then
			read TRAFFIC < $FILE_CNT.traffic

			let "TRAFFIC = TRAFFIC - $8"

			if [ $TRAFFIC -lt 0 ]; then
				TRAFFIC=0
			fi
		fi
		# ---------------------------------------------------------
		# we save the remain traffic for connection (bytes) on file
		# ---------------------------------------------------------
		write_FILE $TRAFFIC $FILE_CNT.traffic

		if [ $TRAFFIC -eq 0 -a -z "$LOGOUT" ]; then

			LOGOUT=true

			ask_nodog_to_logout_user

		fi
		# ---------------------------------------------------------
	fi
	# ---------------------------------------------------------

	# --------------------------------------------------------------------
	# TIME POLICY
	# --------------------------------------------------------------------
	if [ -z "$MAX_TIME" ]; then
		MAX_TIME=0
	fi

	if [ $MAX_TIME -gt 0 ]; then
		# --------------------------------------------------------------------
		# WE CHECK FOR THE TIME REMAIN FOR CONNECTION (SECS) SAVED ON FILE
		# --------------------------------------------------------------------
		TIMEOUT=0

		if [ -s $FILE_CNT.timeout -a $7 -gt $LOGIN_LOGOUT_TIME ]; then # 15 sec: login - logout to know time remain...
			read TIMEOUT < $FILE_CNT.timeout

			let "TIMEOUT = TIMEOUT - $7"

			if [ $TIMEOUT -lt 0 ]; then
				TIMEOUT=0
			fi
		fi
		# ---------------------------------------------------------
		# we save the time remain for connection (secs) on file
		# ---------------------------------------------------------
		write_FILE $TIMEOUT $FILE_CNT.timeout

		if [ $TIMEOUT -eq 0 -a -z "$LOGOUT" ]; then

			LOGOUT=true

			ask_nodog_to_logout_user

		fi
		# ---------------------------------------------------------
	fi
	# ---------------------------------------------------------

	if [ $6 -eq -1 ]; then # disconneted (logout implicito)

		OP=EXIT

		if [ $MAX_TRAFFIC -gt 0 -a $TRAFFIC -gt 0 ]; then

			# bonus

			let "TIMEOUT = TIMEOUT + $BONUS_FOR_EXIT"

			write_FILE $TIMEOUT $FILE_CNT.timeout

		fi

	fi

	if [ $6 -ne 0 ]; then # logout

		write_to_LOG "$5" "$4" "$2" "$1" "$TIMEOUT" "$TRAFFIC"

		# we remove the data saved on file
		rm -f $DIR_REQ/$5.uid

	fi

	if [ $# -gt 8 ]; then

		shift 8

		info_notified_from_nodog "$@"

	elif [ -n "$LOGOUT" ]; then

		OUTPUT="<html><body>LOGOUT</body></html>"

	else

		OUTPUT="<html><body>OK</body></html>"

	fi

# 	set +x
}

ask_nodog_to_check_for_users_info() {

#	set -x

	# we request nodog to check for users logout or disconnect...
	# -----------------------------------------------------------------------------
	# NB: we need PREFORK_CHILD > 2
	# -----------------------------------------------------------------------------
	FILE_TMP=/tmp/nodog.check.$$

	send_request_to_nodog "http://$GATEWAY/check" $FILE_TMP "-i"

	if [ -s $FILE_TMP ]; then

		read HTTP_VERSION HTTP_STATUS HTTP_DESCR < $FILE_TMP

		if [ "$HTTP_STATUS" = "204" ]; then # 204 - HTTP_NO_CONTENT

			sleep 9

			ask_nodog_to_check_for_users_info

		fi

		rm -f $FILE_TMP
	fi

#	set +x
}

load_value_session() {

#	set -x

	if [ -s $TMP_FORM_FILE ]; then

		i=1
		while read LINE
		do
			eval v$i=\"$LINE\"

			let "i = i + 1"
		done < $TMP_FORM_FILE

	fi

#	set +x
}

get_user_nome_cognome() {

#	set -x

	TMP_FORM_FILE=$DIR_REG/$UUID.reg

	load_value_session

	if [ -n "$v1$v2" ]; then
		USER="$v1 $v2"
	else
		USER=$UUID
	fi

#	set +x
}

user_welcome() {

#	set -x

	# $1 -> mac
	# $2 -> ip
	# $3 -> redirect
	# $4 -> gateway
	# $5 -> timeout
	# $6 -> token
	# $7 -> ap

	get_user_context_connection

	if [ -n "$GATEWAY" ]; then

		# check if he is still connected...

		ask_nodog_status_user

		echo "$OUTPUT" | grep PERMIT >/dev/null 2>&1

		if [ $? -ne 0 ]; then

			unset UUID

			rm -f $FILE_CTX # NB: FILE_CTX e' settato da get_user_context_connection()...

		fi
	fi

	if [ -z "$UUID" ]; then

		PARAM="$7 $4 $1 $2 $3 $5 $6"

		if [ "$PARAM" != "      " ]; then
			save_connection_request "$PARAM"
		fi

	fi

	ENABLE_BUTTON=a
	DISABLE_BUTTON=del
	CONNECTION_CLOSE=1

	if [ -n "$UUID" ]; then
		# connesso
		REGISTRATI=$DISABLE_BUTTON
		LOGIN=$DISABLE_BUTTON
		LOGOUT=$ENABLE_BUTTON
		STATUS=$ENABLE_BUTTON
	else
		# non connesso
		REGISTRATI=$ENABLE_BUTTON
		LOGIN=$ENABLE_BUTTON
		LOGOUT=$DISABLE_BUTTON
		STATUS=$DISABLE_BUTTON

		UUID_TO_APPEND=1

		user_has_valid_MAC "$@"

		if [ -n "$SSL_CLIENT_CERT_SERIAL" ]; then
			user_has_valid_cert "$@"
		fi
	fi

	CA_CERT_URL="$HTTP_HOST/CA/ServerCA.cer"

	if [ -n "$BROWSER_MSIE" ]; then
		CA_CERT_URL="$HTTP_HOST/CA/ServerCA.der"
	else
		case $HTTP_USER_AGENT in
		*AppleWebKit*KHTML*)
			CA_CERT_URL="$HTTP_HOST/wi-auth/form/$HTTP_ACCEPT_LANGUAGE/install_safari.tmpl"
		;;
		esac
	fi

	# post
	# certficato CA
	# logout page
	# registrazione
	# bottone 1
	# bottone 2
	# bottone 3
	# bottone 4

	print_page https://$HTTP_HOST/login \
				  $CA_CERT_URL \
				  $HTTP_HOST $HTTP_HOST \
				  https://$HTTP_HOST/registrazione \
				  $REGISTRATI $REGISTRATI \
				  $LOGIN		  $LOGIN \
				  $LOGOUT	  $LOGOUT \
				  $STATUS	  $STATUS

#	set +x
}

# set -x

# global var
BASE_NAME=$(basename $0 .sh)

if [ -z "$HTTP_ACCEPT_LANGUAGE" -o ! -d ../form/$HTTP_ACCEPT_LANGUAGE ]; then
	HTTP_ACCEPT_LANGUAGE=en
fi

FORM_FILE_DIR=../form/$HTTP_ACCEPT_LANGUAGE

# we can do services... ?
if [ -x $WIFI_PORTAL_HOME/ANOMALIA ]; then
	ANOMALIA_page
fi

# set +x

# --------------------------------
#  session cookie (no NAT)
# --------------------------------
SESSION_ID=$REMOTE_ADDR
# --------------------------------
#  session cookie (with NAT)
# --------------------------------
#	if [ -n "$HTTP_COOKIE" ]; then
#		SESSION_ID=$HTTP_COOKIE
#	else
#     SET_COOKIE=SESS_$$
#		SESSION_ID=$SET_COOKIE
#	fi
# --------------------------------

# ---------------------------------------------------------------------
# NB: se cambia qualcosa qui, bisogna cambiarlo anche nel .env di admin
# ---------------------------------------------------------------------
DIR_REQ=../request
DIR_CTX=../login
DIR_CNT=../counter
DIR_POLICY=../policy
DIR_REG=../registration
DIR_STAT=../stat
# ---------------------------------------------------------------------

TIMEOUT=0
TRAFFIC=0
EXIT_VALUE=0
LOGIN_LOGOUT_TIME=0
BACK_TAG="<a class=\"back\" href=\"#\" onclick=\"history.go(-1);return false;\">INDIETRO</a>"
MSG_ANOMALIA="Problema in autenticazione (anomalia %s). Si prega di riprovare, se il problema persiste contattare: $TELEFONO"
LDAP_USER_PARAM="-x -D $WIAUTH_USER_LDAP_BINDDN -w $WIAUTH_USER_LDAP_PWD -h $WIAUTH_USER_LDAP_SERVER -p $WIAUTH_USER_LDAP_PORT"
LDAP_CARD_PARAM="-x -D $WIAUTH_CARD_LDAP_BINDDN -w $WIAUTH_CARD_LDAP_PWD -h $WIAUTH_CARD_LDAP_SERVER -p $WIAUTH_CARD_LDAP_PORT"

export OUTPUT BASE_NAME FORM_FILE_DIR OP DIR_REQ DIR_CTX DIR_CNT DIR_POLICY DIR_REG DIR_STAT FILE_CTX TRAFFIC \
		 TIMEOUT MAC IP GATEWAY AP TMP_FORM_FILE UUID SET_COOKIE SESSION_ID CALLER_ID \
		 USER SIGNED_DATA BACK_TAG UUID_TO_APPEND LDAP_USER_PARAM \
		 LDAP_CARD_PARAM EXIT_VALUE CONNECTION_CLOSE POLICY WA_UID LOGIN_LOGOUT_TIME TMPFILE

# more environment...
if [ -n "$FILE_TO_SOURCE" ]; then
   . $FILE_TO_SOURCE
fi

#!/bin/sh

# nodog.fw

networkMatchIface_do() {
	awk -f - $* <<EOF
function ip2int(ip) {
	for (ret=0,n=split(ip,a,"\."),x=1;x<=n;x++) ret=or(lshift(ret,8),a[x]) 
	return ret
}

BEGIN {
	slpos=index(ARGV[1],"/")
	tipaddr=ip2int(substr(ARGV[1],0,slpos-1))
	tnetmask=compl(2**(32-int(substr(ARGV[1],slpos+1)))-1)
	tnetwork=and(tipaddr,tnetmask)

	slpos=index(ARGV[2],"/")
	if (slpos == 0) {
		ipaddr=ip2int(ARGV[2])
		netmask=ip2int(ARGV[3])
	} else {
		ipaddr=ip2int(substr(ARGV[2],0,slpos-1))
		netmask=compl(2**(32-int(substr(ARGV[2],slpos+1)))-1)
	}
	network=and(ipaddr,netmask)

	if (network == tnetwork)
		exit(1)

	m=and(tnetwork,network)
	if (m == network)
		exit(2)
	if (m == tnetwork)
		exit(3)
	exit(0)
}
EOF
}

networkMatchIface() {
	iface=$1
	net=$2

	match=0
	if which ip >/dev/null; then
		#ip addr show dev $iface | awk '/inet/{print $2}' | while read ip; do
		ip route show | grep "dev $iface " |  awk '{print $1}' | while read ip; do
			networkMatchIface_do $net $ip
			match=$?
			if [ $match -eq 1 ]; then
				exit $match
			fi
		done
		match=$?
	else
		#ifconfig $iface | awk '/inet/{i=$2;n=$4;gsub("^[^:]*:","",i);gsub("^[^:]*:","",n);print i" "n}' | while read ip nm; do
		route | awk '{if($8=="$iface"){print $1" "$3}}' | while read ip nm; do
			networkMatchIface_do $net $ip $nm
			if [ $match -eq 1 ]; then
				exit $match
			fi
		done
		match=$?
	fi
	return $match
}

#-----------------------------------
# START FUNCTION
#-----------------------------------
initialize_fw() {

	#---------------------------------------------------------------
	# Enable IP routing. Required if your firewall is protecting a
	# network, NAT included
	#---------------------------------------------------------------
	echo "1" > /proc/sys/net/ipv4/ip_forward
	#---------------------------------------------------------------
	# Disable routing triangulation. Respond to queries out
	# the same interface, not another. Helps to maintain state
	# Also protects against IP spoofing
	#---------------------------------------------------------------
	echo "1" > /proc/sys/net/ipv4/conf/all/rp_filter

	# Load all the kernel modules we need
	for module in ipt_TOS xt_mac ipt_ACCOUNT; do
		lsmod | grep $module >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			insmod $module 2>/dev/null
		fi
	done

	clear_fw

	# Flush all user-defined chains

	$IPTABLES -t filter -N NoCat 2>/dev/null
	$IPTABLES -t filter -F NoCat
	for ifacein in $InternalDevice; do
		for ifaceout in $ExternalDevice; do
			$IPTABLES -t filter -D FORWARD -i $ifacein  -o $ifaceout -j NoCat 2>/dev/null
			$IPTABLES -t filter -D FORWARD -i $ifaceout -o $ifacein  -j NoCat 2>/dev/null
			$IPTABLES -t filter -A FORWARD -i $ifacein  -o $ifaceout -j NoCat
			$IPTABLES -t filter -A FORWARD -i $ifaceout -o $ifacein  -j NoCat
		done
	done

	$IPTABLES -t filter -N NoCat_Ports 2>/dev/null
	$IPTABLES -t filter -F NoCat_Ports
	$IPTABLES -t filter -D NoCat -j NoCat_Ports 2>/dev/null
	$IPTABLES -t filter -A NoCat -j NoCat_Ports

	$IPTABLES -t filter -N NoCat_Inbound 2>/dev/null
	$IPTABLES -t filter -F NoCat_Inbound
	$IPTABLES -t filter -D NoCat -j NoCat_Inbound 2>/dev/null
	$IPTABLES -t filter -A NoCat -j NoCat_Inbound

	$IPTABLES -t nat -N NoCat_Capture 2>/dev/null
	$IPTABLES -t nat -F NoCat_Capture
	$IPTABLES -t nat -D PREROUTING -j NoCat_Capture 2>/dev/null
	$IPTABLES -t nat -A PREROUTING -j NoCat_Capture

	$IPTABLES -t nat -N NoCat_NAT  2>/dev/null
	$IPTABLES -t nat -F NoCat_NAT

	# Only nat if we're not routing

	$IPTABLES -t nat -D POSTROUTING -j NoCat_NAT 2>/dev/null
	[ $RouteOnly -gt 0 ] || $IPTABLES -t nat -A POSTROUTING -j NoCat_NAT

	$IPTABLES -t mangle -N NoCat 2>/dev/null
	$IPTABLES -t mangle -F NoCat
	$IPTABLES -t mangle -D PREROUTING -j NoCat 2>/dev/null
	$IPTABLES -t mangle -A PREROUTING -j NoCat

	if [ $MembersOnly -gt 0 ]; then
	  classes="1 2"
	else
	  classes="1 2 3"
	fi

	# Handle tagged traffic. The current service classes by fwmark are:
	# -----------------------------------------------------------------
	# 1: Owner
	# 2: Co-op
	# 3: Public
	# 4: Free
	# -----------------------------------------------------------------
	for iface in $InternalDevice; do
		ifaceinout=0
		for ifaceout in $ExternalDevice; do
			if [ "$iface" == "$ifaceout" ]; then
				ifaceinout=1
			fi
		done

		for net in $LocalNetwork; do
			networkMatchIface $iface $net
			[ $? -eq 1 ] || continue

			for fwmark in $classes; do
				# Only forward tagged traffic per class
				$fwd -i $iface -s $net -m mark --mark $fwmark -j ACCEPT

				# Masquerade permitted connections.
				for ifaceout in $MasqueradeDevice; do
					$nat -o $ifaceout -s $net -m mark --mark $fwmark -j MASQUERADE
				done
			done
			if [ $MembersOnly -gt 0 ]; then
				for ifaceout in $MasqueradeDevice; do
					$nat -o $ifaceout -s $net -m mark --mark 3 -j MASQUERADE
				done
			fi

			# Allow web traffic to the specified hosts, and don't capture connections intended for them
			open_fw "$AuthServiceIP $1 $AllowedWebHosts"

			# Accept forward and back traffic to/from DNSAddr
			if [ "$DNSAddr" ]; then
				for dns in $DNSAddr; do
					$fwd -o $iface -d $net -s $dns -j ACCEPT

					for prot in tcp udp; do
						$fwd -i $iface -s $net -d $dns -p $prot --dport 53 -j ACCEPT
						$nat -p  $prot -s $net -d $dns          --dport 53 -j MASQUERADE

						# Force unauthenticated DNS traffic through this server.
						# Of course, only the first rule of this type will match.
						# But it's easier to leave them all in ATM.
						$redirect -i $iface -m mark --mark 4 -p $prot --dport 53 -j DNAT --to-destination $dns:53
					done
				done
			fi

			if [ "$ifaceinout" == "1" ]; then
				# Set packets from internal devices to fw mark 4, or 'denied', by default.
				$mangle -i $iface -s $net -j MARK --set-mark 4
			fi
		done

		if [ "$ifaceinout" != "1" ]; then
			# Set packets from internal devices to fw mark 4, or 'denied', by default
			$mangle -i $iface -j MARK --set-mark 4
		fi
	done

	# Redirect outbound non-auth web traffic to the local gateway process except to windowsupdate.microsoft.com, which is broken.
	# If MembersOnly is active, then redirect public class as well
	#
	#if [ $MembersOnly -gt 0 ]; then
	#  nonauth="3 4"
	#else
		nonauth="4"
	#fi

	for port in 80; do
		for mark in $nonauth; do
			$redirect -m mark --mark $mark -p tcp --dport $port -j REDIRECT --to-port $GatewayPort
		done
	done

	# Lock down more ports for public users, if specified. Port restrictions are not applied to co-op and owner class users
	#
	# There are two philosophies in restricting access:
	#
	# That Which Is Not Specifically Permitted Is Denied
	# That Which Is Not Specifically    Denied Is Permitted
	#
	# If "IncludePorts" is defined, the default policy will be to  deny all traffic, and only allow the ports mentioned
	# If "ExcludePorts" is defined, the default policy will be to allow all traffic,      except to the ports mentioned
	#
	# If both are defined, ExcludePorts will be ignored, and the default policy
	# will be to deny all traffic, allowing everything in IncludePorts, and issue a warning

	if [ "$IncludePorts" ]; then
		if [ "$ExcludePorts" ]; then
			echo "WARNING: ExcludePorts and IncludePorts are both defined"
			echo "Ignoring 'ExcludePorts'. Please check your configuration"
		fi

		# Enable all ports in IncludePorts
		for iface in $InternalDevice; do
			for port in $IncludePorts; do
				$ports -p tcp -i $iface --dport $port -m mark --mark 3 -j ACCEPT
				$ports -p udp -i $iface --dport $port -m mark --mark 3 -j ACCEPT
			done

			# Always permit access to the GatewayPort (or we can't logout)
			$ports -p tcp -i $iface --dport $GatewayPort -j ACCEPT
			$ports -p udp -i $iface --dport $GatewayPort -j ACCEPT

			# ...and disable access to the rest
			$ports -p tcp -i $iface -m mark --mark 3 -j DROP
			$ports -p udp -i $iface -m mark --mark 3 -j DROP
		done

	elif [ "$ExcludePorts" ]; then
		# If ExcludePorts has entries, simply deny access to them
		for iface in $InternalDevice; do
			for port in $ExcludePorts; do
				$ports -p tcp -i $iface --dport $port -m mark --mark 3 -j DROP
				$ports -p udp -i $iface --dport $port -m mark --mark 3 -j DROP
			done
		done
	fi

	# Disable access on the external to GatewayPort from anything but the AuthServiceIP
	for src in $AuthServiceIP; do
		for ifaceout in $ExternalDevice; do
			$fwd -i $ifaceout -s ! $src -p tcp --dport $GatewayPort -j DROP
		done
	done

	# Filter policy
	$fwd -j DROP

	if [ $MaxSegmentSize -gt 0 ]; then
		for iface in $ExternalDevice; do
			$IPTABLES -t mangle -A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -o $iface -j TCPMSS --clamp-mss-to-pmtu
		done
	fi

	# Account traffic

	$IPTABLES -t mangle -N AccountIn 2>/dev/null
	$IPTABLES -t mangle -F AccountIn
	$IPTABLES -t mangle -N AccountOu 2>/dev/null
	$IPTABLES -t mangle -F AccountOu

	for iface in $InternalDevice; do
		 $IPTABLES -t mangle -D POSTROUTING -o $iface -j AccountIn 2>/dev/null
		 $IPTABLES -t mangle -A POSTROUTING -o $iface -j AccountIn
	done

	for iface in $ExternalDevice; do
		 $IPTABLES -t mangle -D POSTROUTING -o $iface -j AccountOu 2>/dev/null
		 $IPTABLES -t mangle -A POSTROUTING -o $iface -j AccountOu
	done

	for srv in "$AuthServiceIP"; do
		$IPTABLES -t mangle -A AccountIn -s "$srv" -j RETURN
		$IPTABLES -t mangle -A AccountOu -d "$srv" -j RETURN
	done

	for net in $LocalNetwork; do
		$IPTABLES -t mangle -A AccountIn -s "$net" -j RETURN
		$IPTABLES -t mangle -A AccountOu -d "$net" -j RETURN
	 	$IPTABLES -t mangle -A AccountIn -j ACCOUNT --addr "$net" --tname "$net"
	 	$IPTABLES -t mangle -A AccountOu -j ACCOUNT --addr "$net" --tname "$net"
	done
	# --------------------------------------------------------------------------
}

access_fw() {

	cmd=$1
	mac=`echo $2 | tr '[A-Z]' '[a-z]'`
	ip=$3
	class=$4

	if [ -z "$class" ]; then
		class=Public
	fi

	  if [ "$class" = "Owner" ]; then
		mark=1
	elif [ "$class" = "Member" ]; then
		mark=2
	elif [ "$class" = "Public" ]; then
		mark=3
	else
		echo "FATAL: Bad class: $class!"
		exit 1
	fi

	# Mark outbound traffic from this node.
	if [ "$mac" == "00:00:00:00:00:00" ]; then
		$IPTABLES -t mangle $cmd NoCat -s $ip -j MARK --set-mark $mark
	else
		$IPTABLES -t mangle $cmd NoCat -m mac --mac-source $mac -s $ip -j MARK --set-mark $mark
	fi

	# Mark inbound traffic to this node.
	$IPTABLES -t filter $cmd NoCat_Inbound -d $ip -j ACCEPT
}

clear_fw() {

	$IPTABLES -F
	$IPTABLES -t nat -F
	$IPTABLES -t mangle -F
	$IPTABLES -t filter -F
	$IPTABLES -t nat -X
	$IPTABLES -t mangle -X
	$IPTABLES -t filter -X
}

reset_fw() {

	$IPTABLES -t filter -D FORWARD -j NoCat			2>/dev/null
	$IPTABLES -t nat -D PREROUTING -j NoCat_Capture 2>/dev/null

	if [ $RouteOnly -eq 0 ]; then
		$IPTABLES -t nat -D POSTROUTING -j NoCat_NAT 2>/dev/null
	fi

	$IPTABLES -t mangle -D PREROUTING -j NoCat 2>/dev/null
}

open_fw() {

	# $1 host list

	if [ "$1" ]; then
		for host in $1; do
			for port in 80 443; do
				for ifaceout in $MasqueradeDevice; do
					$nat -o $ifaceout -s $net -d $host -p tcp --dport $port -j MASQUERADE
				done

				$redirect -s $net -d $host -p tcp --dport $port -j RETURN
				$fwd      -s $net -d $host -p tcp --dport $port -j ACCEPT
				$fwd      -d $net -s $host -p tcp --sport $port -j ACCEPT
			done
		done
	fi
}

list_open_fw() {

	echo `$IPTABLES -L -nt mangle | grep 'MARK set 0x2'| cut -d' ' -f12`
}

check_arp() {

	for iface in $InternalDevice; do
		arping -q -c 1 -I $iface $1
	done

	egrep -q "^$1 " /proc/$$/net/arp

	exit $?
}

do_cmd() {

	# Note: your PATH is inherited from the gateway process

	if [ -x /usr/sbin/iptables ]; then
		IPTABLES=/usr/sbin/iptables
	else
		IPTABLES="echo iptables"
	fi

		  fwd="$IPTABLES -t filter -A NoCat"
		ports="$IPTABLES -t filter -A NoCat_Ports"
		  nat="$IPTABLES -t nat    -A NoCat_NAT"
	redirect="$IPTABLES -t nat    -A NoCat_Capture"
	  mangle="$IPTABLES -t mangle -A NoCat"

	case "$1" in
		arp)			shift;	  check_arp		  "$@" ;; #				   (IP)
		deny)			shift;     access_fw "-D" "$@" ;; # (CMD) (MAC) (IP) [Class]
		clear)      shift;      clear_fw		  "$@" ;;
		reset)      shift;      reset_fw		  "$@" ;;
		permit)		shift;     access_fw "-A" "$@" ;; # (CMD) (MAC) (IP) [Class]

		openlist)			  list_open_fw				 ;;
		initialize) shift; initialize_fw		  "$1" ;;
	esac
}
#-----------------------------------
# END FUNCTION
#-----------------------------------

export RouteOnly MasqueradeDevice DNSAddr IncludePorts ExcludePorts AllowedWebHosts ExternalDevice \
		 InternalDevice LocalNetwork GatewayPort AuthServiceIP MembersOnly MaxSegmentSize IPTABLES

# load eventuale script configuration

if [ -n "$FW_CONF" -a -s "$FW_CONF" ]; then
	. $FW_CONF
fi

# ---------------------------------------------------------------------------------------------------------------------------------------------------
# RouteOnly       Required only if you DO NOT want your gateway to act as a NAT. Give this only if you're running a strictly routed
#                 network, and don't need the gateway to enable NAT for you
#
# DNSAddr         *If* you choose not to run DNS on your internal network, specify the address(es) of one or more domain name server
#                 on the Internet that wireless clients can use to get out. Should be the same DNS that your DHCP server hands out
#
# IncludePorts    Specify TCP ports to allow access to when public class users login. All others will be denied
#
# ExcludePorts    Specify TCP ports to denied access to when public class users login. All others will be allowed. Note that you should
#                 use either IncludePorts or ExcludePorts, but not both. If neither is specified, access is granted to all ports to public class users.
#                 You should *always* exclude port 25, unless you want to run an portal for wanton spam sending. Users should have their
#                 own way of sending mail. It sucks, but that's the way it is. Comment this out *only if* you're using IncludePorts instead
#
# AllowedWebHosts List any domains that you would like to allow web access (TCP port 80 and 443) BEFORE logging in (this is the
#                 pre-'skip' stage, so be careful about what you allow
#
# MasqueradeDevice
#
# ExternalDevice  The interface connected to the Internet. Usually 'eth0' or 'eth1' under Linux, or maybe even 'ppp0' if you're running PPP or PPPoE
#
# InternalDevice  Required if and only if your machine has more than two network interfaces. Must be set to the interface connected to your local
#                 network, normally your wireless card
#
# LocalNetwork    Must be set to the network address and net mask of your internal network. You can use the number of bits in the netmask
#                 (e.g. /16, /24, etc.) or the full x.x.x.x specification
#
# GatewayPort     The TCP port to bind the gateway service to. 5280 is de-facto standard for NoCatAuth. Change this only if you absolutely need to
#
# AuthServiceIP   The address of your authentication service. You must use an IP address if DNS resolution isn't available at gateway startup
#
# MembersOnly     Give this if you want to disable public access (i.e. unauthenticated 'skip' button access). You'll also want to
#						point AuthServiceIP somewhere that doesn't include a skip button (likeat your own Auth server)
#
# MaxSegmentSize  Give this if you want to reduce MTU
# ---------------------------------------------------------------------------------------------------------------------------------------------------
RouteOnly=${RouteOnly:-0}
MembersOnly=${MembersOnly:-1}
GatewayPort=${GatewayPort:-5280}
MaxSegmentSize=${MaxSegmentSize:-0}

export DosAllowTries=${DosAllowTries:-5}
export DosTimeInterval=${DosTimeInterval:-60}

# (
# echo "ENVIRONMENT:"
# echo "-----------------------------------------------------------"
# env
# echo "-----------------------------------------------------------"
# echo "STDERR:"
# echo "-----------------------------------------------------------"
# set -x
do_cmd "$@"
# set +x
# echo "-----------------------------------------------------------"
# ) 2>/tmp/nodog_fw.$$ >&2

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ULib C++ Library: USSLSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>USSLSocket Class Reference</h1><!-- doxytag: class="USSLSocket" --><!-- doxytag: inherits="UTCPSocket" --><div class="dynheader">
Inheritance diagram for USSLSocket:</div>
<div class="dynsection">
<div class="center"><img src="classUSSLSocket__inherit__graph.png" border="0" usemap="#USSLSocket_inherit__map" alt="Inheritance graph"/></div>
<map name="USSLSocket_inherit__map" id="USSLSocket_inherit__map">
<area shape="rect" id="node2" href="classUTCPSocket.html" title="UTCPSocket" alt="" coords="5,83,96,111"/><area shape="rect" id="node4" href="classUSocket.html" title="basic IP socket functionality" alt="" coords="17,6,84,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for USSLSocket:</div>
<div class="dynsection">
<div class="center"><img src="classUSSLSocket__coll__graph.png" border="0" usemap="#USSLSocket_coll__map" alt="Collaboration graph"/></div>
<map name="USSLSocket_coll__map" id="USSLSocket_coll__map">
<area shape="rect" id="node2" href="classUTCPSocket.html" title="UTCPSocket" alt="" coords="59,529,149,557"/><area shape="rect" id="node4" href="classUSocket.html" title="basic IP socket functionality" alt="" coords="71,449,137,477"/><area shape="rect" id="node6" href="classUIPAddress.html" title="UIPAddress" alt="" coords="189,266,275,294"/><area shape="rect" id="node8" href="classUString.html" title="UString" alt="" coords="16,99,80,127"/><area shape="rect" id="node11" href="classUStringRep.html" title="UStringRep" alt="" coords="5,6,91,34"/><area shape="rect" id="node14" href="unionuupcAddress.html" title="uupcAddress" alt="" coords="187,99,277,127"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classUSSLSocket-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a313ff5aaadc686fea8bd71a75fa968e9"></a><!-- doxytag: member="USSLSocket::USSLSocket" ref="a313ff5aaadc686fea8bd71a75fa968e9" args="(bool bSocketIsIPv6=false, SSL_CTX *ctx=0, bool tls=false)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>USSLSocket</b> (bool bSocketIsIPv6=false, SSL_CTX *ctx=0, bool tls=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d750b5adb4dc39dc05b2141d7ee0f92"></a><!-- doxytag: member="USSLSocket::setActive" ref="a1d750b5adb4dc39dc05b2141d7ee0f92" args="(bool flag)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setActive</b> (bool flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c65a49c008ef2c19638ea5b3d901f73"></a><!-- doxytag: member="USSLSocket::secureConnection" ref="a4c65a49c008ef2c19638ea5b3d901f73" args="(int fd)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>secureConnection</b> (int fd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a33ce67f6abd2cd5f16133b9880ff3212">useDHFile</a> (const char *dh_file=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#abe397cea9afdffa6dbcde5c7b64b0d44">setContext</a> (const char *cert_file, const char *private_key_file, const char *<a class="el" href="structpasswd.html">passwd</a>, const char *CAfile, const char *CApath, int mode=SSL_VERIFY_PEER_STRICT|SSL_VERIFY_CLIENT_ONCE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a7c4e740a7eda5dbed1e7c9389354d3f0">setVerifyDepth</a> (int depth=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a3d9bc38a4665daccefff331f2927cfe8">setVerifyCallback</a> (verify_cb func, int mode=SSL_VERIFY_PEER_STRICT|SSL_VERIFY_CLIENT_ONCE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a9583a25e500844ac715f09ede70116b0">getVerifyResult</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">X509 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a9a65c67ec80d74ac60be678852968b23">getPeerCertificate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a820b0fc0c31b6abf52f14b813f6ad010">askForClientCertificate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c09abfbcc82e7fa3b2329234f69f24"></a><!-- doxytag: member="USSLSocket::isSSL" ref="af8c09abfbcc82e7fa3b2329234f69f24" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isSSL</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a786f1585b36e0da5afc0e3648ad29801"></a><!-- doxytag: member="USSLSocket::closesocket" ref="a786f1585b36e0da5afc0e3648ad29801" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>closesocket</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21209e4f23e144e3af29ad57775479a3"></a><!-- doxytag: member="USSLSocket::getMsgError" ref="a21209e4f23e144e3af29ad57775479a3" args="(const char *&amp;pmsg)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>getMsgError</b> (const char *&amp;pmsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a62f67a3914309051da7bbc5aae9c810b">send</a> (const void *pData, int iDataLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a3328737002f68158e924f0f0ebf6c2bc">recv</a> (void *pBuffer, int iBufferLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a1b5266042cfe25954c792612f46b7d80">connectServer</a> (const <a class="el" href="classUString.html">UString</a> &amp;server, int iServPort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classUSocket.html">USocket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#ab6601bf1976add465a5a5f012cf9781e">acceptClient</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUSocket.html">USocket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept</a> (<a class="el" href="classUSSLSocket.html">USSLSocket</a> *pcNewConnection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classUSocket.html">USocket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a2ee5990b6b2038ff1475142004117cac">acceptClient</a> (<a class="el" href="classUSocket.html">USocket</a> *pcNewConnection)</td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0994a70c5b2a37a6ad9d4a432d9a932"></a><!-- doxytag: member="USSLSocket::method" ref="ae0994a70c5b2a37a6ad9d4a432d9a932" args="" -->
static SSL_METHOD *&nbsp;</td><td class="memItemRight" valign="bottom"><b>method</b></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae842be1813d1574c78f884114a2f1d8d"></a><!-- doxytag: member="USSLSocket::status" ref="ae842be1813d1574c78f884114a2f1d8d" args="(bool flag) const " -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>status</b> (bool flag) const </td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c1cf1b2fcdcb58de2f9c03685c0a65a"></a><!-- doxytag: member="USSLSocket::status" ref="a5c1cf1b2fcdcb58de2f9c03685c0a65a" args="(SSL *ssl, int ret, bool flag)" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>status</b> (SSL *ssl, int ret, bool flag)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8b81eda4d76d78824ffe66fe8c427d"></a><!-- doxytag: member="USSLSocket::ssl" ref="a8f8b81eda4d76d78824ffe66fe8c427d" args="" -->
SSL *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ssl</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d616bcd9ba4b49c267cdc9ac45f5d78"></a><!-- doxytag: member="USSLSocket::ctx" ref="a8d616bcd9ba4b49c267cdc9ac45f5d78" args="" -->
SSL_CTX *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ctx</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a015d9c25c176479dcac9e7dfff920059"></a><!-- doxytag: member="USSLSocket::ret" ref="a015d9c25c176479dcac9e7dfff920059" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ret</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefae69a2d2ce6d5d369a753bb92665f5"></a><!-- doxytag: member="USSLSocket::active" ref="aefae69a2d2ce6d5d369a753bb92665f5" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>active</b></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b774e0e0aa74bd82c34de016bab8dce"></a><!-- doxytag: member="USSLSocket::UServer_Base" ref="a3b774e0e0aa74bd82c34de016bab8dce" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a3b774e0e0aa74bd82c34de016bab8dce">UServer_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83e46667f7e5b84a34d23bdb1b4cc818"></a><!-- doxytag: member="USSLSocket::USSLFtpClient" ref="a83e46667f7e5b84a34d23bdb1b4cc818" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a83e46667f7e5b84a34d23bdb1b4cc818">USSLFtpClient</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbda4add37917857a6a5126c72ce234"></a><!-- doxytag: member="USSLSocket::UServer" ref="a3dbda4add37917857a6a5126c72ce234" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a3dbda4add37917857a6a5126c72ce234">UServer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9942209984963ab5a1ac8736ad0ae468"></a><!-- doxytag: member="USSLSocket::UClientImage" ref="a9942209984963ab5a1ac8736ad0ae468" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSLSocket.html#a9942209984963ab5a1ac8736ad0ae468">UClientImage</a></td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad193ec26179fee25a85e4648cdd4a3e3"></a><!-- doxytag: member="USSLSocket::accept" ref="ad193ec26179fee25a85e4648cdd4a3e3" args="(USSLSocket *pcNewConnection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUSocket.html">USocket</a> * USSLSocket::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUSSLSocket.html">USSLSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>pcConnection</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept a pending connection, the <a class="el" href="classUSocket.html" title="basic IP socket functionality">USocket</a> pointed to by the provided parameter is modified to refer to the newly connected socket. The remote IP Address and port number are also returned </p>

<p>Reimplemented from <a class="el" href="classUSocket.html#afe635340565fa7eba1e7139955d63532">USocket</a>.</p>

</div>
</div>
<a class="anchor" id="a2ee5990b6b2038ff1475142004117cac"></a><!-- doxytag: member="USSLSocket::acceptClient" ref="a2ee5990b6b2038ff1475142004117cac" args="(USocket *pcNewConnection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUSocket.html">USocket</a> * USSLSocket::acceptClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUSocket.html">USocket</a> *&nbsp;</td>
          <td class="paramname"> <em>pcNewConnection</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to accept a new connection on the server socket. Further communications on the newly connected socket are made via the newly created <a class="el" href="classUTCPSocket.html">UTCPSocket</a> instance of which a pointer is returned when the connection is accepted. We create a <a class="el" href="classUTCPSocket.html">UTCPSocket</a> instance and pass this to the base class <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> method to accept the pending connection on this <a class="el" href="classUTCPSocket.html">UTCPSocket</a> instance. </p>

<p>Reimplemented from <a class="el" href="classUTCPSocket.html#aa295f33b935a3a7b02db63f066d9ac0e">UTCPSocket</a>.</p>

</div>
</div>
<a class="anchor" id="ab6601bf1976add465a5a5f012cf9781e"></a><!-- doxytag: member="USSLSocket::acceptClient" ref="ab6601bf1976add465a5a5f012cf9781e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUSocket.html">USocket</a> * USSLSocket::acceptClient </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to accept a new connection on the server socket. Further communications on the newly connected socket are made via the newly created <a class="el" href="classUSSLSocket.html">USSLSocket</a> instance of which a pointer is returned when the connection is accepted. We create a <a class="el" href="classUSSLSocket.html">USSLSocket</a> instance and pass this to the base class <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> method to accept the pending connection on this <a class="el" href="classUSSLSocket.html">USSLSocket</a> instance </p>

<p>Reimplemented from <a class="el" href="classUTCPSocket.html#a2f62fc69e757b38b1dad2d13eb38d9fb">UTCPSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a820b0fc0c31b6abf52f14b813f6ad010"></a><!-- doxytag: member="USSLSocket::askForClientCertificate" ref="a820b0fc0c31b6abf52f14b813f6ad010" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USSLSocket::askForClientCertificate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Server side RE-NEGOTIATE asking for client cert </p>

</div>
</div>
<a class="anchor" id="a1b5266042cfe25954c792612f46b7d80"></a><!-- doxytag: member="USSLSocket::connectServer" ref="a1b5266042cfe25954c792612f46b7d80" args="(const UString &amp;server, int iServPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool USSLSocket::connectServer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUString.html">UString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iServPort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to connect the socket to a server SSL that is specified by the provided host name and port number. We call the SSL_connect() function to perform the connection </p>

<p>Reimplemented from <a class="el" href="classUTCPSocket.html#ad7c0417f01fb02c2bc3ff72f156302f5">UTCPSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a9a65c67ec80d74ac60be678852968b23"></a><!-- doxytag: member="USSLSocket::getPeerCertificate" ref="a9a65c67ec80d74ac60be678852968b23" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">X509* USSLSocket::getPeerCertificate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get peer certificate. Should be called after connect() or <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> when using verification NB: OpenSSL already tested the cert validity during SSL handshake and returns a X509 ptr just if the certificate is valid... </p>

</div>
</div>
<a class="anchor" id="a9583a25e500844ac715f09ede70116b0"></a><!-- doxytag: member="USSLSocket::getVerifyResult" ref="a9583a25e500844ac715f09ede70116b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long USSLSocket::getVerifyResult </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the peer certificate verification result. Should be called after connect() or <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> where the verification is done. On the server side this should be done on the new object returned by <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> and not on the listener object! If you don't get X509_V_OK and don't trust the peer you should disconnect. If you trust the peer (or perhaps ask the user if he/she does) but didn't get X509_V_OK you might consider adding this certificate to the trusted CA certificates loaded by <a class="el" href="classUSSLSocket.html#abe397cea9afdffa6dbcde5c7b64b0d44">setContext()</a>, but don't add invalid certificates... </p>

</div>
</div>
<a class="anchor" id="a3328737002f68158e924f0f0ebf6c2bc"></a><!-- doxytag: member="USSLSocket::recv" ref="a3328737002f68158e924f0f0ebf6c2bc" args="(void *pBuffer, int iBufferLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USSLSocket::recv </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iBufLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to receive a block of data on the connected socket. The parameters signify the payload receiving buffer and its size. If the socket is not connected, then we failed on assertion, otherwise we call the <a class="el" href="classUSSLSocket.html#a3328737002f68158e924f0f0ebf6c2bc">recv()</a> method to receive the data, returning the number of bytes actually readden </p>

<p>Reimplemented from <a class="el" href="classUSocket.html#a8822b76fde425ed0472e3f6faaa8e40c">USocket</a>.</p>

</div>
</div>
<a class="anchor" id="a62f67a3914309051da7bbc5aae9c810b"></a><!-- doxytag: member="USSLSocket::send" ref="a62f67a3914309051da7bbc5aae9c810b" args="(const void *pData, int iDataLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USSLSocket::send </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pPayload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iPayloadLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to send a block of data to the remote connection. The parameters signify the Data Payload and its size. If the socket is not connected, then we failed on assertion, otherwise we call the <a class="el" href="classUSSLSocket.html#a62f67a3914309051da7bbc5aae9c810b">send()</a> method to send the data, returning the number of bytes actually sent </p>

<p>Reimplemented from <a class="el" href="classUSocket.html#af0b6a659f6f9caaccf0b0694bd33002b">USocket</a>.</p>

</div>
</div>
<a class="anchor" id="abe397cea9afdffa6dbcde5c7b64b0d44"></a><!-- doxytag: member="USSLSocket::setContext" ref="abe397cea9afdffa6dbcde5c7b64b0d44" args="(const char *cert_file, const char *private_key_file, const char *passwd, const char *CAfile, const char *CApath, int mode=SSL_VERIFY_PEER_STRICT|SSL_VERIFY_CLIENT_ONCE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USSLSocket::setContext </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cert_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>private_key_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>passwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>CAfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>CApath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>SSL_VERIFY_PEER_STRICT&nbsp;|&nbsp;SSL_VERIFY_CLIENT_ONCE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load a certificate. A socket used on the server side needs to have a certificate (but a temporary RSA session certificate may be created if you don't load one yourself). The client side can also load certificates but it is not required. The files should be in ASCII PEM format and the certificate and the private key can either be in the same file or two separate files. OpenSSL's standard password prompt will be used if the private key uses a password. You should load the certificate before calling <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> or connect(). Should the peer certificate be verified ? The arguments specify the locations of trusted CA certificates used in the verification. Either CAfile or CApath can be set to NULL. See man SSL_CTX_load_verify_locations(3) for format information. Should be called before <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> or connect() if used and the verification result is then available by calling <a class="el" href="classUSSLSocket.html#a9583a25e500844ac715f09ede70116b0">getVerifyResult()</a> on the connected socket (the new socket from <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> on the server side, the same socket on the client side). Returns true on success </p>

</div>
</div>
<a class="anchor" id="a3d9bc38a4665daccefff331f2927cfe8"></a><!-- doxytag: member="USSLSocket::setVerifyCallback" ref="a3d9bc38a4665daccefff331f2927cfe8" args="(verify_cb func, int mode=SSL_VERIFY_PEER_STRICT|SSL_VERIFY_CLIENT_ONCE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USSLSocket::setVerifyCallback </td>
          <td>(</td>
          <td class="paramtype">verify_cb&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>SSL_VERIFY_PEER_STRICT&nbsp;|&nbsp;SSL_VERIFY_CLIENT_ONCE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Verify callback </p>

</div>
</div>
<a class="anchor" id="a7c4e740a7eda5dbed1e7c9389354d3f0"></a><!-- doxytag: member="USSLSocket::setVerifyDepth" ref="a7c4e740a7eda5dbed1e7c9389354d3f0" args="(int depth=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USSLSocket::setVerifyDepth </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For successful verification, the peer certificate must be signed with the CA certificate directly or indirectly (a proper certificate chain exists). The certificate chain length from the CA certificate to the peer certificate can be set in the verify_depth field of the SSL_CTX and SSL structures. (The value in SSL is inherited from SSL_CTX when you create an SSL structure using the SSL_new() API). Setting verify_depth to 1 means that the peer certificate must be directly signed by the CA certificate. </p>

</div>
</div>
<a class="anchor" id="a33ce67f6abd2cd5f16133b9880ff3212"></a><!-- doxytag: member="USSLSocket::useDHFile" ref="a33ce67f6abd2cd5f16133b9880ff3212" args="(const char *dh_file=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USSLSocket::useDHFile </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dh_file</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load Diffie-Hellman parameters from file. These are used to generate a DH key exchange. See man SSL_CTX_set_tmp_dh_callback(3) and www.skip-vpn.org/spec/numbers.html for more information. Should be called before <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">accept()</a> or connect() if used. Returns true on success </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ulib/ssl/net/<a class="el" href="sslsocket_8h_source.html">sslsocket.h</a></li>
<li>src/ulib/ssl/net/sslsocket.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Jan 8 19:50:48 2010 for ULib C++ Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ULib C++ Library: USOAPParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>USOAPParser Class Reference</h1><!-- doxytag: class="USOAPParser" --><!-- doxytag: inherits="UXMLParser,URPCParser" -->
<p><a class="el" href="classUSOAPParser.html" title="USOAPParser is a parser SOAP based on Expat (Expat is a stream-oriented parser).">USOAPParser</a> is a parser SOAP based on Expat (Expat is a stream-oriented parser).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="soap__parser_8h_source.html">soap_parser.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for USOAPParser:</div>
<div class="dynsection">
<div class="center"><img src="classUSOAPParser__inherit__graph.png" border="0" usemap="#USOAPParser_inherit__map" alt="Inheritance graph"/></div>
<map name="USOAPParser_inherit__map" id="USOAPParser_inherit__map">
<area shape="rect" id="node2" href="classUXMLParser.html" title="UXMLParser is a parser XML based on Expat (Expat is a stream&#45;oriented parser)." alt="" coords="5,6,99,34"/><area shape="rect" id="node4" href="classURPCParser.html" title="URPCParser is a parser RPC." alt="" coords="123,6,211,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for USOAPParser:</div>
<div class="dynsection">
<div class="center"><img src="classUSOAPParser__coll__graph.png" border="0" usemap="#USOAPParser_coll__map" alt="Collaboration graph"/></div>
<map name="USOAPParser_coll__map" id="USOAPParser_coll__map">
<area shape="rect" id="node2" href="classUXMLParser.html" title="UXMLParser is a parser XML based on Expat (Expat is a stream&#45;oriented parser)." alt="" coords="5,414,99,442"/><area shape="rect" id="node4" href="classURPCParser.html" title="URPCParser is a parser RPC." alt="" coords="123,414,211,442"/><area shape="rect" id="node6" href="classURPCEnvelope.html" title="URPCEnvelope" alt="" coords="103,241,209,269"/><area shape="rect" id="node8" href="classUString.html" title="UString" alt="" coords="216,99,280,127"/><area shape="rect" id="node16" href="classUXMLElement.html" title="UXMLElement" alt="" coords="363,327,467,355"/><area shape="rect" id="node11" href="classUStringRep.html" title="UStringRep" alt="" coords="205,6,291,34"/><area shape="rect" id="node14" href="classUVector_3_01UString_01_4.html" title="UVector\&lt; UString \&gt;" alt="" coords="43,99,173,127"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classUSOAPParser-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a639cce1b7547fad0f9d01e1d829bacf7"></a><!-- doxytag: member="USOAPParser::USOAPParser" ref="a639cce1b7547fad0f9d01e1d829bacf7" args="(UVector&lt; UString &gt; *arg=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>USOAPParser</b> (UVector&lt; <a class="el" href="classUString.html">UString</a> &gt; *arg=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af255b92ea40b2283362c860c084c1e74"></a><!-- doxytag: member="USOAPParser::clearData" ref="af255b92ea40b2283362c860c084c1e74" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>clearData</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7201e81bd391a71448c390e5775c6be3"></a><!-- doxytag: member="USOAPParser::zero" ref="a7201e81bd391a71448c390e5775c6be3" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>zero</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5760b016b2fe6cdba63a56eb126be5b9"></a><!-- doxytag: member="USOAPParser::initParser" ref="a5760b016b2fe6cdba63a56eb126be5b9" args="(const char *charset=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>initParser</b> (const char *charset=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99a9650d5463d5aa8bb70429f631bf1b"></a><!-- doxytag: member="USOAPParser::parse" ref="a99a9650d5463d5aa8bb70429f631bf1b" args="(const UString &amp;msg)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>parse</b> (const <a class="el" href="classUString.html">UString</a> &amp;msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e87b95710e4748e391c267d3272adf0"></a><!-- doxytag: member="USOAPParser::getResponse" ref="a7e87b95710e4748e391c267d3272adf0" args="()" -->
<a class="el" href="classUString.html">UString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getResponse</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eed1ea1e6776bcccde5ba252fc9e31b"></a><!-- doxytag: member="USOAPParser::getFaultResponse" ref="a4eed1ea1e6776bcccde5ba252fc9e31b" args="()" -->
<a class="el" href="classUString.html">UString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getFaultResponse</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a6ffeeb49fc472ae9a5ec050cd1ba3"></a><!-- doxytag: member="USOAPParser::processMessage" ref="a38a6ffeeb49fc472ae9a5ec050cd1ba3" args="(const UString &amp;msg, URPCObject &amp;object, bool &amp;bContainsFault)" -->
<a class="el" href="classUString.html">UString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>processMessage</b> (const <a class="el" href="classUString.html">UString</a> &amp;msg, <a class="el" href="classURPCObject.html">URPCObject</a> &amp;object, bool &amp;bContainsFault)</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6ae8ce94797939fae7339fd034fd8a7"></a><!-- doxytag: member="USOAPParser::str_allocate" ref="ae6ae8ce94797939fae7339fd034fd8a7" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_allocate</b> ()</td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a148190c626ce3dc4d29ebd1043b46bb1"></a><!-- doxytag: member="USOAPParser::str_ns" ref="a148190c626ce3dc4d29ebd1043b46bb1" args="" -->
U_MEMORY_TEST <br class="typebreak"/>
U_MEMORY_ALLOCATOR static <br class="typebreak"/>
U_MEMORY_DEALLOCATOR <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_ns</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cce749689d3683e12f303fb37f988bf"></a><!-- doxytag: member="USOAPParser::str_true" ref="a2cce749689d3683e12f303fb37f988bf" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_true</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf9b3e0c226f594b0fe90efea181c500"></a><!-- doxytag: member="USOAPParser::str_fault" ref="abf9b3e0c226f594b0fe90efea181c500" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_fault</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7d0ef3064768f9b1d121d61c2c0baa2"></a><!-- doxytag: member="USOAPParser::str_xmlns" ref="af7d0ef3064768f9b1d121d61c2c0baa2" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_xmlns</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a455aca655b5079df3c8b95cc9eca6e14"></a><!-- doxytag: member="USOAPParser::str_version11" ref="a455aca655b5079df3c8b95cc9eca6e14" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_version11</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee059a20883e58720389b69ae29a4430"></a><!-- doxytag: member="USOAPParser::str_mustUnderstand" ref="aee059a20883e58720389b69ae29a4430" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_mustUnderstand</b></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a543cbf336e82571fcf1988cf511d03fd"></a><!-- doxytag: member="USOAPParser::startElement" ref="a543cbf336e82571fcf1988cf511d03fd" args="(const XML_Char *name, const XML_Char **attrs)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>startElement</b> (const XML_Char *name, const XML_Char **attrs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3410db1afa41f8bc4c3728b190a58a71"></a><!-- doxytag: member="USOAPParser::characterData" ref="a3410db1afa41f8bc4c3728b190a58a71" args="(const XML_Char *str, int len)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>characterData</b> (const XML_Char *str, int len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a292e825e366079665f087146afe6903f"></a><!-- doxytag: member="USOAPParser::endElement" ref="a292e825e366079665f087146afe6903f" args="(const XML_Char *name)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>endElement</b> (const XML_Char *name)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64984fd4ac065f363fd486634f88143c"></a><!-- doxytag: member="USOAPParser::tree" ref="a64984fd4ac065f363fd486634f88143c" args="" -->
UTree&lt; <a class="el" href="classUXMLElement.html">UXMLElement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>tree</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af08d927634edb69377b644fd61cdb4d9"></a><!-- doxytag: member="USOAPParser::body" ref="af08d927634edb69377b644fd61cdb4d9" args="" -->
UTree&lt; <a class="el" href="classUXMLElement.html">UXMLElement</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>body</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aace6213cd383c07180ba56a81eefdf89"></a><!-- doxytag: member="USOAPParser::header" ref="aace6213cd383c07180ba56a81eefdf89" args="" -->
UTree&lt; <a class="el" href="classUXMLElement.html">UXMLElement</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>header</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34c8846bc90adee93d3ff782f98b4c96"></a><!-- doxytag: member="USOAPParser::method" ref="a34c8846bc90adee93d3ff782f98b4c96" args="" -->
UTree&lt; <a class="el" href="classUXMLElement.html">UXMLElement</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>method</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classUSOAPParser.html" title="USOAPParser is a parser SOAP based on Expat (Expat is a stream-oriented parser).">USOAPParser</a> is a parser SOAP based on Expat (Expat is a stream-oriented parser). </p>
<p>SOAP (Simple Object Access Protocol) is a simple XML based protocol to let applications exchange information over HTTP. SOAP is fundamentally a stateless, one-way message exchange paradigm.</p>
<p>The following SOAP 1.2 message contains a number of elements, attributes, and values: ------------------------------------------------------------------------------------- &lt;?xml version='1.0' ?&gt; &lt;soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;soap:Header&gt; &lt;m:reservation xmlns:m="http://travelcompany.example.org/reservation" soap:role="http://www.w3.org/2003/05/soap-envelope/role/next" soap:mustUnderstand="true"&gt; &lt;m:reference&gt;uuid:093a2da1-q345-739r-ba5d-pqff98fe8j7d&lt;/m:reference&gt; &lt;m:dateAndTime&gt;2001-11-29T13:20:00.000-05:00&lt;/m:dateAndTime&gt; &lt;/m:reservation&gt; &lt;n:passenger xmlns:n="http://mycompany.example.com/employees" soap:role="http://www.w3.org/2003/05/soap-envelope/role/next" soap:mustUnderstand="true"&gt; &lt;n:name&gt;Åke Jógvan Øyvind&lt;/n:name&gt; &lt;/n:passenger&gt; &lt;/soap:Header&gt; &lt;soap:Body&gt; &lt;p:itinerary xmlns:p="http://travelcompany.example.org/reservation/travel"&gt; &lt;p:departure&gt; &lt;p:departing&gt;New York&lt;/p:departing&gt; &lt;p:arriving&gt;Los Angeles&lt;/p:arriving&gt; &lt;p:departureDate&gt;2001-12-14&lt;/p:departureDate&gt; &lt;p:departureTime&gt;late afternoon&lt;/p:departureTime&gt; &lt;p:seatPreference&gt;aisle&lt;/p:seatPreference&gt; &lt;/p:departure&gt; &lt;p:return&gt; &lt;p:departing&gt;Los Angeles&lt;/p:departing&gt; &lt;p:arriving&gt;New York&lt;/p:arriving&gt; &lt;p:departureDate&gt;2001-12-20&lt;/p:departureDate&gt; &lt;p:departureTime&gt;mid-morning&lt;/p:departureTime&gt; &lt;p:seatPreference/&gt; &lt;/p:return&gt; &lt;/p:itinerary&gt; &lt;q:lodging xmlns:q="http://travelcompany.example.org/reservation/hotels"&gt; &lt;q:preference&gt;none&lt;/q:preference&gt; &lt;/q:lodging&gt; &lt;/soap:Body&gt; &lt;/soap:Envelope&gt; -------------------------------------------------------------------------------------</p>
<p>SOAP envelope: The outermost element information item of a SOAP message. ------------------------------------------------------------------------ The SOAP Envelope element information item has:</p>
<ul>
<li>A local name of Envelope.</li>
<li>A namespace name of "http://www.w3.org/2003/05/soap-envelope".</li>
<li>Zero or more namespace qualified attribute information items amongst its attributes property.</li>
<li>One or two element information items in its [children] property in order as follows:</li>
<li>1. An optional Header element information item.</li>
<li>2. A mandatory Body element information item. ------------------------------------------------------------------------</li>
</ul>
<p>The encodingStyle attribute information item indicates the encoding rules used to serialize parts of a SOAP message. -------------------------------------------------------------------------------------------------------------------- The encodingStyle attribute information item has:</p>
<ul>
<li>A local name of encodingStyle.</li>
<li>A namespace name of "http://www.w3.org/2003/05/soap-envelope".</li>
<li>The encodingStyle attribute information item is of type xs:anyURI. Its value identifies a set of serialization rules that can be used to deserialize the SOAP message.</li>
<li>The encodingStyle attribute information item MAY appear on the following:</li>
<li>1. A SOAP header block.</li>
<li>2. A child element information item of the SOAP Body element information item if that child is not a SOAP Fault element information.</li>
<li>3. A child element information item of the SOAP Detail element information item.</li>
<li>4. Any descendent of 1, 2, and 3 above. --------------------------------------------------------------------------------------------------------------------</li>
</ul>
<p>-------------------------------------------------------------------------------------------------------------------- SOAP header: A collection of zero or more SOAP header blocks each of which might be targeted at any SOAP receiver within the SOAP message path. SOAP header block: An element information item used to delimit data that logically constitutes a single computational unit within the SOAP header.</p>
<p>The type of a SOAP header block is identified by the XML expanded name of the header block element information item. The Header element information item has:</p>
<ul>
<li>A local name of Header.</li>
<li>A namespace name of "http://www.w3.org/2003/05/soap-envelope".</li>
<li>Zero or more namespace qualified attribute information items in its attributes property.</li>
<li>Zero or more namespace qualified element information items in its children property.</li>
<li>Each child element information item of the SOAP Header is called a SOAP header block.</li>
</ul>
<p>Each SOAP header block element information item: . MUST have a namespace name property which has a value, that is the name of the element MUST be namespace qualified. . MAY have any number of character information item children. Child character information items whose character code is amongst the white space characters as defined by XML 1.0 are considered significant. . MAY have any number of element information item children. Such element information items MAY be namespace qualified. . MAY have zero or more attribute information items in its attributes property. Among these MAY be any or all of the following, which have special significance for SOAP processing: . - encodingStyle attribute information item. . - role attribute information item. . - mustUnderstand attribute information item. . - relay attribute information item.</p>
<p>A SOAP header is an extension mechanism that provides a way to pass information in SOAP messages that is not application payload. Such "control" information includes, for example, passing directives or contextual information related to the processing of the message. This allows a SOAP message to be extended in an application-specific manner. The immediate child elements of the soap:Header element are called header blocks, and represent a logical grouping of data which, as shown later, can individually be targeted at SOAP nodes that might be encountered in the path of a message from a sender to an ultimate receiver.</p>
<p>SOAP headers have been designed in anticipation of various uses for SOAP, many of which will involve the participation of other SOAP processing nodes - called SOAP intermediaries - along a message's path from an initial SOAP sender to an ultimate SOAP receiver. This allows SOAP intermediaries to provide value-added services. Headers, as shown later, may be inspected, inserted, deleted or forwarded by SOAP nodes encountered along a SOAP message path. --------------------------------------------------------------------------------------------------------------------</p>
<p>-------------------------------------------------------------------------------------------------------------------- SOAP body: A collection of zero or more element information items targeted at an ultimate SOAP receiver in the SOAP message path.</p>
<p>The Body element information item has:</p>
<ul>
<li>A local name of Body.</li>
<li>A namespace name of "http://www.w3.org/2003/05/soap-envelope".</li>
<li>Zero or more namespace qualified attribute information items in its attributes property.</li>
<li>Zero or more namespace qualified element information items in its children property.</li>
<li>The Body element information item MAY have any number of character information item children whose character code is amongst the white space characters as defined by XML 1.0. These are considered significant.</li>
</ul>
<p>All child element information items of the SOAP Body element information item:</p>
<ul>
<li>SHOULD have a namespace name property which has a value, that is the name of the element SHOULD be namespace qualified. Note: Namespace qualified elements tend to produce messages whose interpretation is less ambiguous than those with unqualified elements. The use of unqualified elements is therefore discouraged.</li>
<li>MAY have any number of character information item children. Child character information items whose character code is amongst the white space characters as defined by XML 1.0 are considered significant.</li>
<li>MAY have any number of element information item children. Such element information items MAY be namespace qualified.</li>
<li>MAY have zero or more attribute information items in its attributes property. Among these MAY be the following, which has special significance for SOAP processing: encodingStyle attribute information item.</li>
</ul>
<p>SOAP defines one particular direct child of the SOAP body, the SOAP fault, which is used for reporting errors. -------------------------------------------------------------------------------------------------------------------- </p>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ulib/xml/soap/<a class="el" href="soap__parser_8h_source.html">soap_parser.h</a></li>
<li>src/ulib/xml/soap/soap_parser.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Dec 31 17:08:57 2009 for ULib C++ Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

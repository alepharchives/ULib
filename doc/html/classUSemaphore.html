<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ULib C++ Library: USemaphore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>USemaphore Class Reference</h1><!-- doxytag: class="USemaphore" -->
<p><code>#include &lt;<a class="el" href="semaphore_8h_source.html">semaphore.h</a>&gt;</code></p>

<p><a href="classUSemaphore-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSemaphore.html#a28d29e4877cd770982438838ddf97f81">init</a> (sem_t *ptr=0, unsigned resource=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSemaphore.html#af5fbba3ccbe45ed2b0c25764aae33132">~USemaphore</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSemaphore.html#a3b3ad2fcb4229e280ab64ed90a816dd9">wait</a> (timeout_t timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a554ec82dd8cf735a602957ebe4687127"></a><!-- doxytag: member="USemaphore::lock" ref="a554ec82dd8cf735a602957ebe4687127" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lock</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSemaphore.html#ab43b8ba2ebc2a67c92f0e4bf8c8e2328">post</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a142a0ef6fc827edeed8d3118e3ff1a15"></a><!-- doxytag: member="USemaphore::unlock" ref="a142a0ef6fc827edeed8d3118e3ff1a15" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>unlock</b> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65a9e07a0ee9759f947dfc332bd55d8d"></a><!-- doxytag: member="USemaphore::sem" ref="a65a9e07a0ee9759f947dfc332bd55d8d" args="" -->
sem_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>sem</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9d8a7acc00b5d2ec72120af99dc0519"></a><!-- doxytag: member="USemaphore::flag" ref="ad9d8a7acc00b5d2ec72120af99dc0519" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>flag</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff589865ba96dd16f3374d94f67dfb5d"></a><!-- doxytag: member="USemaphore::broken" ref="aff589865ba96dd16f3374d94f67dfb5d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>broken</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A semaphore is generally used as a synchronization object between multiple threads or to protect a limited and finite resource such as a memory or thread pool. The semaphore has a counter which only permits access by one or more threads when the value of the semaphore is non-zero. Each access reduces the current value of the semaphore by 1. One or more threads can wait on a semaphore until it is no longer 0, and hence the semaphore can be used as a simple thread synchronization object to enable one thread to pause others until the thread is ready or has provided data for them. Semaphores are typically used as a counter for protecting or limiting concurrent access to a given resource, such as to permitting at most "x" number of threads to use resource "y", for example </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af5fbba3ccbe45ed2b0c25764aae33132"></a><!-- doxytag: member="USemaphore::~USemaphore" ref="af5fbba3ccbe45ed2b0c25764aae33132" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USemaphore::~USemaphore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroying a semaphore also removes any system resources associated with it. If a semaphore has threads currently waiting on it, those threads will all continue when a semaphore is destroyed </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a28d29e4877cd770982438838ddf97f81"></a><!-- doxytag: member="USemaphore::init" ref="a28d29e4877cd770982438838ddf97f81" args="(sem_t *ptr=0, unsigned resource=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USemaphore::init </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>resource</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The initial value of the semaphore can be specified. An initial value is often used when used to lock a finite resource or to specify the maximum number of thread instances that can access a specified resource.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resource</em>&nbsp;</td><td>specify initial resource count or 1 default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab43b8ba2ebc2a67c92f0e4bf8c8e2328"></a><!-- doxytag: member="USemaphore::post" ref="ab43b8ba2ebc2a67c92f0e4bf8c8e2328" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USemaphore::post </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Posting to a semaphore increments its current value and releases the first thread waiting for the semaphore if it is currently at 0. Interestingly, there is no support to increment a semaphore by any value greater than 1 to release multiple waiting threads in either pthread or the win32 API. Hence, if one wants to release a semaphore to enable multiple threads to execute, one must perform multiple post operations </p>

</div>
</div>
<a class="anchor" id="a3b3ad2fcb4229e280ab64ed90a816dd9"></a><!-- doxytag: member="USemaphore::wait" ref="a3b3ad2fcb4229e280ab64ed90a816dd9" args="(timeout_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USemaphore::wait </td>
          <td>(</td>
          <td class="paramtype">timeout_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait is used to keep a thread held until the semaphore counter is greater than 0. If the current thread is held, then another thread must increment the semaphore. Once the thread is accepted, the semaphore is automatically decremented, and the thread continues execution.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if timed out </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>period in milliseconds to wait </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ulib/utility/<a class="el" href="semaphore_8h_source.html">semaphore.h</a></li>
<li>src/ulib/utility/semaphore.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Jan 7 17:25:01 2010 for ULib C++ Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

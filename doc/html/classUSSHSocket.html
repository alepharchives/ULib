<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ULib C++ Library: USSHSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>USSHSocket Class Reference</h1><!-- doxytag: class="USSHSocket" --><!-- doxytag: inherits="UTCPSocket" -->
<p><code>#include &lt;<a class="el" href="sshsocket_8h_source.html">sshsocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for USSHSocket:</div>
<div class="dynsection">
<div class="center"><img src="classUSSHSocket__inherit__graph.png" border="0" usemap="#USSHSocket_inherit__map" alt="Inheritance graph"/></div>
<map name="USSHSocket_inherit__map" id="USSHSocket_inherit__map">
<area shape="rect" id="node2" href="classUTCPSocket.html" title="UTCPSocket" alt="" coords="5,83,96,111"/><area shape="rect" id="node4" href="classUSocket.html" title="basic IP socket functionality" alt="" coords="17,6,84,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for USSHSocket:</div>
<div class="dynsection">
<div class="center"><img src="classUSSHSocket__coll__graph.png" border="0" usemap="#USSHSocket_coll__map" alt="Collaboration graph"/></div>
<map name="USSHSocket_coll__map" id="USSHSocket_coll__map">
<area shape="rect" id="node2" href="classUTCPSocket.html" title="UTCPSocket" alt="" coords="59,529,149,557"/><area shape="rect" id="node4" href="classUSocket.html" title="basic IP socket functionality" alt="" coords="71,449,137,477"/><area shape="rect" id="node6" href="classUIPAddress.html" title="UIPAddress" alt="" coords="189,266,275,294"/><area shape="rect" id="node8" href="classUString.html" title="UString" alt="" coords="16,99,80,127"/><area shape="rect" id="node11" href="classUStringRep.html" title="UStringRep" alt="" coords="5,6,91,34"/><area shape="rect" id="node14" href="unionuupcAddress.html" title="uupcAddress" alt="" coords="187,99,277,127"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classUSSHSocket-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48adc8b6815ce7250409fcf66809dc87"></a><!-- doxytag: member="USSHSocket::USSHSocket" ref="a48adc8b6815ce7250409fcf66809dc87" args="(bool bSocketIsIPv6=false)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>USSHSocket</b> (bool bSocketIsIPv6=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c4b227b53222ecea99ab43fa97a36be"></a><!-- doxytag: member="USSHSocket::close" ref="a2c4b227b53222ecea99ab43fa97a36be" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>close</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf820e0b367bc97f94c48f4cbdd981ce"></a><!-- doxytag: member="USSHSocket::getError" ref="abf820e0b367bc97f94c48f4cbdd981ce" args="()" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getError</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1bb76bbd2876b481f12127f08cc922e"></a><!-- doxytag: member="USSHSocket::SSHConnection" ref="ad1bb76bbd2876b481f12127f08cc922e" args="(int fd)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>SSHConnection</b> (int fd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71b16c5e8a4b476e9a759ab87925ca0e"></a><!-- doxytag: member="USSHSocket::setUser" ref="a71b16c5e8a4b476e9a759ab87925ca0e" args="(const char *_user)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setUser</b> (const char *_user)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80e6f2bfce36cba96899b5559834aaf5"></a><!-- doxytag: member="USSHSocket::setKey" ref="a80e6f2bfce36cba96899b5559834aaf5" args="(const char *_private_key=&quot;/%U/.ssh/id_rsa&quot;, const char *_public_key=&quot;/%U/.ssh/id_rsa.pub&quot;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setKey</b> (const char *_private_key=&quot;/%U/.ssh/id_rsa&quot;, const char *_public_key=&quot;/%U/.ssh/id_rsa.pub&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b62c18b08f1d7758098246ca6081d0f"></a><!-- doxytag: member="USSHSocket::setVerbosity" ref="a0b62c18b08f1d7758098246ca6081d0f" args="(int num=&#45;1)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setVerbosity</b> (int num=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a806c0bee2498e42a11065686e11b7d82"></a><!-- doxytag: member="USSHSocket::sendEOF" ref="a806c0bee2498e42a11065686e11b7d82" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sendEOF</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSHSocket.html#ad92e04001609c65db030c5b9512609fb">send</a> (const void *pData, int iDataLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSHSocket.html#a6e33a0e9339d8569fc2a4850aaedf4e6">recv</a> (void *pBuffer, int iBufferLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSSHSocket.html#a1ccf197cfb553dc766cb9b934b66b958">connectServer</a> (const <a class="el" href="classUString.html">UString</a> &amp;server, int iServPort)</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf8ee0b13fd8c854ef066949e3690570"></a><!-- doxytag: member="USSHSocket::status" ref="aaf8ee0b13fd8c854ef066949e3690570" args="() U_NO_EXPORT" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>status</b> () U_NO_EXPORT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1143241a544f026a451bec136652ab3"></a><!-- doxytag: member="USSHSocket::status" ref="af1143241a544f026a451bec136652ab3" args="(int n)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>status</b> (int n)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a547f45d34cec4b60beee5652f17022ce"></a><!-- doxytag: member="USSHSocket::user" ref="a547f45d34cec4b60beee5652f17022ce" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>user</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa275a09962cf1c645c5395dcb329a677"></a><!-- doxytag: member="USSHSocket::buffer" ref="aa275a09962cf1c645c5395dcb329a677" args="" -->
ssh_buffer&nbsp;</td><td class="memItemRight" valign="bottom"><b>buffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62c4760df027657c5a66e255f797870a"></a><!-- doxytag: member="USSHSocket::channel" ref="a62c4760df027657c5a66e255f797870a" args="" -->
ssh_channel&nbsp;</td><td class="memItemRight" valign="bottom"><b>channel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a479e3f73d85ade539c2db83436dff1b1"></a><!-- doxytag: member="USSHSocket::session" ref="a479e3f73d85ade539c2db83436dff1b1" args="" -->
ssh_session&nbsp;</td><td class="memItemRight" valign="bottom"><b>session</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace508705fb5ccbc26a8d2db35d244408"></a><!-- doxytag: member="USSHSocket::public_key" ref="ace508705fb5ccbc26a8d2db35d244408" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>public_key</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab84417b1804b7d0254e5b4f892a50d8a"></a><!-- doxytag: member="USSHSocket::private_key" ref="ab84417b1804b7d0254e5b4f892a50d8a" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>private_key</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa52b5350679af7edeb4962bd8992960e"></a><!-- doxytag: member="USSHSocket::ret" ref="aa52b5350679af7edeb4962bd8992960e" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ret</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e0d779b7f77f4a4bf6f48a0f10f03eb"></a><!-- doxytag: member="USSHSocket::auth" ref="a3e0d779b7f77f4a4bf6f48a0f10f03eb" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>auth</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Come funziona ssh: -------------------------------------------------------------------------------------------------------------------------- Ogni host su cui è installato ssh possiede una coppia di chiavi RSA (un algoritmo di crittografia a chiave asimmetrica) lunghe 1024 bit, una pubblica ed una privata. In più, ogni utente che utilizza ssh può opzionalmente generare una propria coppia di chiavi RSA. All'atto della connessione, il server comunica al client due chiavi pubbliche: una fissa di 1024 bit che è la vera e propria chiave dell'host e l'altra di 768 bit che viene rigenerata ogni ora. Il client allora genera una sequenza casuale di 256 bit e la codifica con le chiavi pubbliche del server. Da questo momento in poi la connessione viene crittografata con uno degli algoritmi a chiave simmetrica supportati da ssh (IDEA, DES, 3DES, Arcfour, Blowfish) e si passa alla fase di autenticazione. ----------------------------------------------------------------- The SSH protocol was designed for some goals which I resume here:</p>
<p>a) Privacy of data b) Security c) Authentication of the server d) Authentication of the client</p>
<p>The client MUST be sure who's speaking to before entering into any authentication way. That's where the end programmer must ensure the given fingerprints *are* from the legitimate server. A ssh connection must follow the following steps:</p>
<p>1) Before connecting the socket, you can set up if you wish one or other server public key authentication ie. DSA or RSA. You can choose cryptographic algorithms you trust and compression algorithms if any 2) The connection is made. A secure handshake is made, and resulting from it, a public key from the server is gained. You MUST verify that the public key is legitimate 3) The client must authenticate: the two implemented ways are password, and public keys (from dsa and rsa key-pairs generated by openssh). It is harmless to authenticate to a fake server with these keys because the protocol ensures the data you sign can't be used twice. It just avoids man-in-the-middle attacks 4) Now that the user has been authenticated, you must open one or several channels. channels are different subways for information into a single ssh connection. Each channel has a standard stream (stdout) and an error stream (stderr). You can theoretically open an infinity of channel 5) With the channel you opened, you can do several things:</p>
<ul>
<li>Open a shell. You may want to request a pseudo virtual terminal before</li>
<li>Execute a command. The virtual terminal is usable, too</li>
<li>Invoke the sftp subsystem. (look at chapter 6)</li>
<li>invoke your own subsystem. This is out the scope of this document but it is easy to do 6) When everything is finished, just close the channels, and then the connection --------------------------------------------------------------------------------------------------------------------------- </li>
</ul>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1ccf197cfb553dc766cb9b934b66b958"></a><!-- doxytag: member="USSHSocket::connectServer" ref="a1ccf197cfb553dc766cb9b934b66b958" args="(const UString &amp;server, int iServPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool USSHSocket::connectServer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUString.html">UString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iServPort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to connect the socket to a server SSH deamon that is specified by the provided host name and port number. We call the ssh_connect() function to perform the connection </p>

<p>Reimplemented from <a class="el" href="classUTCPSocket.html#ad7c0417f01fb02c2bc3ff72f156302f5">UTCPSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a6e33a0e9339d8569fc2a4850aaedf4e6"></a><!-- doxytag: member="USSHSocket::recv" ref="a6e33a0e9339d8569fc2a4850aaedf4e6" args="(void *pBuffer, int iBufferLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USSHSocket::recv </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iBufLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to receive a block of data on the connected socket. The parameters signify the payload receiving buffer and its size. If the socket is not connected, then we failed on assertion, otherwise we call the <a class="el" href="classUSSHSocket.html#a6e33a0e9339d8569fc2a4850aaedf4e6">recv()</a> method to receive the data, returning the number of bytes actually readden </p>

<p>Reimplemented from <a class="el" href="classUSocket.html#a8822b76fde425ed0472e3f6faaa8e40c">USocket</a>.</p>

</div>
</div>
<a class="anchor" id="ad92e04001609c65db030c5b9512609fb"></a><!-- doxytag: member="USSHSocket::send" ref="ad92e04001609c65db030c5b9512609fb" args="(const void *pData, int iDataLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USSHSocket::send </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pPayload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iPayloadLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to send a block of data to the remote connection. The parameters signify the Data Payload and its size. If the socket is not connected, then we failed on assertion, otherwise we call the <a class="el" href="classUSSHSocket.html#ad92e04001609c65db030c5b9512609fb">send()</a> method to send the data, returning the number of bytes actually sent </p>

<p>Reimplemented from <a class="el" href="classUSocket.html#af0b6a659f6f9caaccf0b0694bd33002b">USocket</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ulib/ssh/net/<a class="el" href="sshsocket_8h_source.html">sshsocket.h</a></li>
<li>src/ulib/ssh/net/sshsocket.cpp</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Apr 9 13:00:58 2010 for ULib C++ Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ULib C++ Library: UQueryNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>UQueryNode Class Reference</h1><!-- doxytag: class="UQueryNode" --><div class="dynheader">
Collaboration diagram for UQueryNode:</div>
<div class="dynsection">
<div class="center"><img src="classUQueryNode__coll__graph.png" border="0" usemap="#UQueryNode_coll__map" alt="Collaboration graph"/></div>
<map name="UQueryNode_coll__map" id="UQueryNode_coll__map">
<area shape="rect" id="node2" href="classUString.html" title="UString" alt="" coords="20,99,84,127"/><area shape="rect" id="node5" href="classUStringRep.html" title="UStringRep" alt="" coords="9,6,95,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classUQueryNode-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>Type</b> { <b>VALUE</b> =  0, 
<b>AND</b> =  1, 
<b>OR</b> =  2, 
<b>NOT</b> =  3
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUQueryNode.html#a54366c702403357c554c582721cc76e4">UQueryNode</a> (const <a class="el" href="classUString.html">UString</a> &amp;d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebf0059ee266902b897b77e1c3f92247"></a><!-- doxytag: member="UQueryNode::UQueryNode" ref="aebf0059ee266902b897b77e1c3f92247" args="(Type t, UQueryNode *l, UQueryNode *r)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>UQueryNode</b> (Type t, <a class="el" href="classUQueryNode.html">UQueryNode</a> *l, <a class="el" href="classUQueryNode.html">UQueryNode</a> *r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUQueryNode.html#adc4875b6d0e77a863052f6584eb2fc4a">getDNFTermRoots</a> (UVector&lt; <a class="el" href="classUQueryNode.html">UQueryNode</a> * &gt; *dest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUQueryNode.html#ac8b826151949fdbd9619a6797c4083e3">getTreeVariables</a> (UVector&lt; <a class="el" href="classUString.html">UString</a> &gt; *positives, UVector&lt; <a class="el" href="classUString.html">UString</a> &gt; *negatives) const </td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classUQueryNode.html">UQueryNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUQueryNode.html#a6e6bebaf739a7d0f70cc5a5c5ede9d70">getDisjunctiveNormalForm</a> (<a class="el" href="classUQueryNode.html">UQueryNode</a> *root)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acae024e9a3cbb886bdb534de90aab9eb"></a><!-- doxytag: member="UQueryNode::left" ref="acae024e9a3cbb886bdb534de90aab9eb" args="" -->
<a class="el" href="classUQueryNode.html">UQueryNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>left</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17657f2033b76e7773c8e13a493da48"></a><!-- doxytag: member="UQueryNode::right" ref="ae17657f2033b76e7773c8e13a493da48" args="" -->
<a class="el" href="classUQueryNode.html">UQueryNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>right</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe8d0239ba869220f1b49d75436beb9b"></a><!-- doxytag: member="UQueryNode::value" ref="abe8d0239ba869220f1b49d75436beb9b" args="" -->
<a class="el" href="classUString.html">UString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>value</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aabb6aef896f5094cad96cb68b63538"></a><!-- doxytag: member="UQueryNode::type" ref="a1aabb6aef896f5094cad96cb68b63538" args="" -->
Type&nbsp;</td><td class="memItemRight" valign="bottom"><b>type</b></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdbb52cfad25fcee9463936c27499c46"></a><!-- doxytag: member="UQueryNode::UQueryParser" ref="afdbb52cfad25fcee9463936c27499c46" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUQueryNode.html#afdbb52cfad25fcee9463936c27499c46">UQueryParser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90bfc41f49864576a8081952951f124f"></a><!-- doxytag: member="UQueryNode::operator&lt;&lt;" ref="a90bfc41f49864576a8081952951f124f" args="(ostream &amp;os, const UQueryNode &amp;e)" -->
ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="classUQueryNode.html">UQueryNode</a> &amp;e)</td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a54366c702403357c554c582721cc76e4"></a><!-- doxytag: member="UQueryNode::UQueryNode" ref="a54366c702403357c554c582721cc76e4" args="(const UString &amp;d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UQueryNode::UQueryNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUString.html">UString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a node of the given type and with the given children. A NOT node must only have a right-hand child, while AND and OR nodes must have both left-hand and right-hand children.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>type of the node (must be AND, OR or NOT) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>subtree to attach as the left-hand child (may be NULL) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>subtree to attach as the right-hand child (may be NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6e6bebaf739a7d0f70cc5a5c5ede9d70"></a><!-- doxytag: member="UQueryNode::getDisjunctiveNormalForm" ref="a6e6bebaf739a7d0f70cc5a5c5ede9d70" args="(UQueryNode *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUQueryNode.html">UQueryNode</a> * UQueryNode::getDisjunctiveNormalForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUQueryNode.html">UQueryNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transforms the designated tree into its Disjunctive Normal Form. The original tree root does not necessarily remain the root of the transformed tree. A simplification is applied: when a term of the form a&amp;!a&amp;(something) is seen, it is deleted unless it is the root of the whole tree. CAUTION: this method can return a NULL pointer; such a result should be interpreted as a "false" boolean expression. Examples are when the original (or resulting) tree is a&amp;!a, or a&amp;!a|b&amp;!b. This method also returns 0 if 'root' is 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>root of the tree to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the root of the transformed tree (may be 0) </dd></dl>

</div>
</div>
<a class="anchor" id="adc4875b6d0e77a863052f6584eb2fc4a"></a><!-- doxytag: member="UQueryNode::getDNFTermRoots" ref="adc4875b6d0e77a863052f6584eb2fc4a" args="(UVector&lt; UQueryNode * &gt; *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UQueryNode::getDNFTermRoots </td>
          <td>(</td>
          <td class="paramtype">UVector&lt; <a class="el" href="classUQueryNode.html">UQueryNode</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the roots of the terms of an tree in DNF form. The DNF is a sum of products. Each term in this sum is represented by a subtree of the tree rooted at the current node. This method produces the <a class="el" href="classUQueryNode.html">UQueryNode</a> pointers that represent the roots of the term subtrees. The tree must first be in DNF. See <a class="el" href="classUQueryNode.html#a6e6bebaf739a7d0f70cc5a5c5ede9d70">getDisjunctiveNormalForm()</a>. For example, if the current node is the root a of DNF tree representing the expression a&amp;b | c | d&amp;e, then three pointers will be stored: one for the 'a&amp;b' subtree, one for the 'c' subtree (a single node) and one for the 'd&amp;e' subtree. If the tree is a single node, then 'this' designates the only term in the sum and it is returned as the root of the unique term. The stored pointers must not be destroyed directly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>output vector of <a class="el" href="classUQueryNode.html">UQueryNode</a> pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8b826151949fdbd9619a6797c4083e3"></a><!-- doxytag: member="UQueryNode::getTreeVariables" ref="ac8b826151949fdbd9619a6797c4083e3" args="(UVector&lt; UString &gt; *positives, UVector&lt; UString &gt; *negatives) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UQueryNode::getTreeVariables </td>
          <td>(</td>
          <td class="paramtype">UVector&lt; <a class="el" href="classUString.html">UString</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>positives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UVector&lt; <a class="el" href="classUString.html">UString</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>negatives</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the variables that are used in the tree root at this node. Example: with the expression a&amp;b&amp;!a&amp;!c, the 'positives' set will contain "a" and "b" and the 'negatives' set will contain "a" and "c". When the intersection between the two sets is not empty and the only binary operator used in the tree is AND, the tree always evaluates to false (because we have an expression of the form (a&amp;!a)&amp;(whatever)). If the only binary operator is OR, the tree always evaluates to true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>positives</em>&nbsp;</td><td>set that receives the values of the variables that are used positively </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>negatives</em>&nbsp;</td><td>set that receives the values of the variables that are used negatively </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ulib/query/<a class="el" href="parser_8h_source.html">parser.h</a></li>
<li>src/ulib/query/query_parser.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat Jan 23 17:17:37 2010 for ULib C++ Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ULib C++ Library: USocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>USocket Class Reference</h1><!-- doxytag: class="USocket" -->
<p>basic IP socket functionality  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="socket_8h_source.html">socket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for USocket:</div>
<div class="dynsection">
<div class="center"><img src="classUSocket__inherit__graph.png" border="0" usemap="#USocket_inherit__map" alt="Inheritance graph"/></div>
<map name="USocket_inherit__map" id="USocket_inherit__map">
<area shape="rect" id="node3" href="classUIptAccount.html" title="UIptAccount" alt="" coords="99,83,189,111"/><area shape="rect" id="node5" href="classUPing.html" title="UPing" alt="" coords="213,83,269,111"/><area shape="rect" id="node7" href="classUTCPSocket.html" title="UTCPSocket" alt="" coords="293,83,384,111"/><area shape="rect" id="node23" href="classUUDPSocket.html" title="UUDPSocket" alt="" coords="408,83,501,111"/><area shape="rect" id="node25" href="classUUnixSocket.html" title="UUnixSocket" alt="" coords="525,83,619,111"/><area shape="rect" id="node9" href="classUFtpClient.html" title="Creates and manages a client connection with a remote FTP server." alt="" coords="17,161,97,189"/><area shape="rect" id="node13" href="classUImapClient.html" title="Creates and manages a client connection with a remote IMAP server." alt="" coords="121,161,212,189"/><area shape="rect" id="node15" href="classUPop3Client.html" title="Creates and manages a client connection with a remote POP3 server." alt="" coords="236,161,327,189"/><area shape="rect" id="node17" href="classUSmtpClient.html" title="Creates and manages a client connection with a remote SMTP server." alt="" coords="351,161,441,189"/><area shape="rect" id="node19" href="classUSSHSocket.html" title="USSHSocket" alt="" coords="465,161,556,189"/><area shape="rect" id="node21" href="classUSSLSocket.html" title="USSLSocket" alt="" coords="580,161,671,189"/><area shape="rect" id="node11" href="classUSSLFtpClient.html" title="Creates and manages a secure client connection with a remote FTP server." alt="" coords="5,238,109,266"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for USocket:</div>
<div class="dynsection">
<div class="center"><img src="classUSocket__coll__graph.png" border="0" usemap="#USocket_coll__map" alt="Collaboration graph"/></div>
<map name="USocket_coll__map" id="USocket_coll__map">
<area shape="rect" id="node2" href="classUIPAddress.html" title="UIPAddress" alt="" coords="189,266,275,294"/><area shape="rect" id="node4" href="classUString.html" title="UString" alt="" coords="16,99,80,127"/><area shape="rect" id="node7" href="classUStringRep.html" title="UStringRep" alt="" coords="5,6,91,34"/><area shape="rect" id="node10" href="unionuupcAddress.html" title="uupcAddress" alt="" coords="187,99,277,127"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classUSocket-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>State</b> { <br/>
&nbsp;&nbsp;<b>CLOSE</b> =  0, 
<b>TIMEOUT</b> =  1, 
<b>BROKEN</b> =  2, 
<b>CONNECT</b> =  3, 
<br/>
&nbsp;&nbsp;<b>LOGIN</b> =  4
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20fc62f827373cb0be37aae18dd13f48"></a><!-- doxytag: member="USocket::USocket" ref="a20fc62f827373cb0be37aae18dd13f48" args="(bool bSocketIsIPv6=false)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>USocket</b> (bool bSocketIsIPv6=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a825e3756f7852f3aa6ec299210e6056f"></a><!-- doxytag: member="USocket::getFd" ref="a825e3756f7852f3aa6ec299210e6056f" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>getFd</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70c8aa518fe10a74e22f4c9eacb16c05"></a><!-- doxytag: member="USocket::isOpen" ref="a70c8aa518fe10a74e22f4c9eacb16c05" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isOpen</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17f09a186e7e53fb266e9e4c7a532d3f"></a><!-- doxytag: member="USocket::isClosed" ref="a17f09a186e7e53fb266e9e4c7a532d3f" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isClosed</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc755c8443e13591269a82f9752dddb1"></a><!-- doxytag: member="USocket::isConnected" ref="adc755c8443e13591269a82f9752dddb1" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isConnected</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a754c449f7b9d8223af341d8ff7e8cb1b"></a><!-- doxytag: member="USocket::isLogin" ref="a754c449f7b9d8223af341d8ff7e8cb1b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isLogin</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9e830817d4f70614fc092cd64cb9d83"></a><!-- doxytag: member="USocket::isTimeout" ref="aa9e830817d4f70614fc092cd64cb9d83" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isTimeout</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad510d85eb1a85adb6a3690236885de81"></a><!-- doxytag: member="USocket::isBroken" ref="ad510d85eb1a85adb6a3690236885de81" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isBroken</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1217c27839be6efad9e3d2715b95d68"></a><!-- doxytag: member="USocket::isSysError" ref="ae1217c27839be6efad9e3d2715b95d68" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isSysError</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a2c487b569842c6524738fc03080c4dd0">checkErrno</a> (int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#aeeedd9dd467a3cc2e8641142808bdefa">checkIO</a> (int iBytesTransferred, int iMaxBytesTransfer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b4283cdd26371dcdcb8f512eb28a372"></a><!-- doxytag: member="USocket::socket" ref="a7b4283cdd26371dcdcb8f512eb28a372" args="(int iSocketType, int protocol=0)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>socket</b> (int iSocketType, int protocol=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4820dcc312573757328a0a8b0965ce38"></a><!-- doxytag: member="USocket::close" ref="a4820dcc312573757328a0a8b0965ce38" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>close</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#af6afbf857fd9a1875428a3002a365664">getSockOpt</a> (int iCodeLevel, int iOptionName, void *pOptionData, uint32_t &amp;iDataLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a59e0688b094fdd5ab29706f3074cd5c0">setSockOpt</a> (int iCodeLevel, int iOptionName, const void *pOptionData, uint32_t iDataLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a71bc5eac4f1b8237ffce461020d4c5f8">connectServer</a> (const <a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;cAddr, int iServPort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#abb900b23d64b5fb858d9ac190c917e78">bind</a> (int iLocalPort=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5a9f327176778a4d92d6ba337bc50d9"></a><!-- doxytag: member="USocket::bind" ref="aa5a9f327176778a4d92d6ba337bc50d9" args="(UIPAddress &amp;cLocalAddr, int iLocalPort=0)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>bind</b> (<a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;cLocalAddr, int iLocalPort=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a1299b5bc49ffe00729a0bd6571e05cbd">listen</a> (int iBackLog=5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#afe635340565fa7eba1e7139955d63532">accept</a> (<a class="el" href="classUSocket.html">USocket</a> *pcConnection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a855d29ae87d399d098829e05916220ce">localPortNumber</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e1237385f9860c2836ec997f6de2d41"></a><!-- doxytag: member="USocket::localIPAddress" ref="a4e1237385f9860c2836ec997f6de2d41" args="()" -->
<a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>localIPAddress</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67acff9b98357079e59f01f4f1f563f0"></a><!-- doxytag: member="USocket::getLocalInfo" ref="a67acff9b98357079e59f01f4f1f563f0" args="()" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getLocalInfo</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a810a388386d247a12ce25c1b310510b7"></a><!-- doxytag: member="USocket::setLocal" ref="a810a388386d247a12ce25c1b310510b7" args="(const UIPAddress &amp;addr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setLocal</b> (const <a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9b37cebe7af0a29acff9bcdb53e84f4"></a><!-- doxytag: member="USocket::isLocalSet" ref="ac9b37cebe7af0a29acff9bcdb53e84f4" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isLocalSet</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a3f4f19c9fede9968e6977d96d97bd033">remotePortNumber</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedf003b252e6200bb895882b06a1dfb9"></a><!-- doxytag: member="USocket::remoteIPAddress" ref="aedf003b252e6200bb895882b06a1dfb9" args="()" -->
<a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>remoteIPAddress</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a992ae6488cf073380d2ecb8fd146bb0e"></a><!-- doxytag: member="USocket::getRemoteInfo" ref="a992ae6488cf073380d2ecb8fd146bb0e" args="()" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getRemoteInfo</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c73757c30fed3ac7f81f31aae8af82b"></a><!-- doxytag: member="USocket::getRemoteInfo" ref="a0c73757c30fed3ac7f81f31aae8af82b" args="(UString &amp;buffer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>getRemoteInfo</b> (<a class="el" href="classUString.html">UString</a> &amp;buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#af94c6040ed50b9c4393097f6b6810b4e">getBufferRCV</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a499903631820419a52118c54e7e3deff"></a><!-- doxytag: member="USocket::getBufferSND" ref="a499903631820419a52118c54e7e3deff" args="()" -->
uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getBufferSND</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3773bcf5746bb226462bc8e17511110f"></a><!-- doxytag: member="USocket::setBufferRCV" ref="a3773bcf5746bb226462bc8e17511110f" args="(uint32_t size)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>setBufferRCV</b> (uint32_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4762c51dc7991a40b29c1b1c6e3d633"></a><!-- doxytag: member="USocket::setBufferSND" ref="aa4762c51dc7991a40b29c1b1c6e3d633" args="(uint32_t size)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>setBufferSND</b> (uint32_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a833a54ea53ae6e054029659733780b0e">setTcpCork</a> (uint32_t corked)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#ac5ac3939478953bdef244223e38c7e12">setTcpDeferAccept</a> (uint32_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85b7fce3fa9fe29ba70c69d577d3d5d4"></a><!-- doxytag: member="USocket::setTcpQuickAck" ref="a85b7fce3fa9fe29ba70c69d577d3d5d4" args="(uint32_t value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setTcpQuickAck</b> (uint32_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ae93189f72c11f8ebf5d743524f8b37"></a><!-- doxytag: member="USocket::setTcpNoDelay" ref="a1ae93189f72c11f8ebf5d743524f8b37" args="(uint32_t value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setTcpNoDelay</b> (uint32_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a21d81dc932813d3728551db0326dc91a">setTimeoutRCV</a> (uint32_t timeoutMS=U_TIMEOUT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac278f05f9831f179cd367489795cee04"></a><!-- doxytag: member="USocket::setTimeoutSND" ref="ac278f05f9831f179cd367489795cee04" args="(uint32_t timeoutMS=U_TIMEOUT)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>setTimeoutSND</b> (uint32_t timeoutMS=U_TIMEOUT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#ab7f67685682bd52c3ea65c97d377f4a0">recvFrom</a> (void *pBuffer, int iBufLength, uint32_t uiFlags, <a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;cSourceIP, int &amp;iSourcePortNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#aa6ec9c594a61e961372ef4718e10ba2b">sendTo</a> (void *pPayload, int iPayloadLength, uint32_t uiFlags, <a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;cDestinationIP, int iDestinationPortNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#acc370dcba9600975d1a875034db07723">recvBinary16Bits</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a10e830a235a8982580ef713979b93412">recvBinary32Bits</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#afe35fa4e9376b03f0ffa96cc1cad6826">sendBinary16Bits</a> (int iData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#ab2d74ccb56a5b06593a0a845e205af38">sendBinary32Bits</a> (uint32_t lData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10f952ef1a3e155c1ee8c80e479812dd"></a><!-- doxytag: member="USocket::isSSL" ref="a10f952ef1a3e155c1ee8c80e479812dd" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isSSL</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9048d2b3240f43877828a958274bf1e2"></a><!-- doxytag: member="USocket::closesocket" ref="a9048d2b3240f43877828a958274bf1e2" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>closesocket</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6d2f09468765f142984390082f9664"></a><!-- doxytag: member="USocket::getMsgError" ref="a1f6d2f09468765f142984390082f9664" args="(char *buffer, uint32_t buffer_size)" -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getMsgError</b> (char *buffer, uint32_t buffer_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#ab998bf35a2ab65e85c13c99a933c58f1">connectServer</a> (const <a class="el" href="classUString.html">UString</a> &amp;server, int iServPort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a222bc630111a7fcf21a3ae519c51ff90">setServer</a> (int port, int iBackLog)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a632628c6c9b72985fd27292b50c0985f"></a><!-- doxytag: member="USocket::setServer" ref="a632628c6c9b72985fd27292b50c0985f" args="(const UString &amp;cLocalAddr, int port, int iBackLog)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>setServer</b> (const <a class="el" href="classUString.html">UString</a> &amp;cLocalAddr, int port, int iBackLog)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classUSocket.html">USocket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#ab2db1524c94b038a4eeace5e272d1e15">acceptClient</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2d89d9f210b94c91e078d9a0c99e9d4"></a><!-- doxytag: member="USocket::acceptClient" ref="ab2d89d9f210b94c91e078d9a0c99e9d4" args="(USocket *pcNewConnection)" -->
virtual <a class="el" href="classUSocket.html">USocket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>acceptClient</b> (<a class="el" href="classUSocket.html">USocket</a> *pcNewConnection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a8822b76fde425ed0472e3f6faaa8e40c">recv</a> (void *pBuffer, int iBufLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#af0b6a659f6f9caaccf0b0694bd33002b">send</a> (const void *pPayload, int iPayloadLength)</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefdb0af43b8effda589312bbb1cb71c3"></a><!-- doxytag: member="USocket::str_allocate" ref="aefdb0af43b8effda589312bbb1cb71c3" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_allocate</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#acb5a12d0fcf3901ee70fed2077399fbc">socket</a> (int domain, int type, int protocol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a3f5c7ad5e7bc631a1615ed616f290496">recv</a> (int fd, void *buf, size_t len, int flags=0)</td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a654cb944ee242032f1a48678a17c708d"></a><!-- doxytag: member="USocket::str_host" ref="a654cb944ee242032f1a48678a17c708d" args="" -->
U_MEMORY_TEST <br class="typebreak"/>
U_MEMORY_ALLOCATOR static <br class="typebreak"/>
U_MEMORY_DEALLOCATOR <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_host</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a736c8ddabe690124fb1ef7f7b29b1b1b"></a><!-- doxytag: member="USocket::str_range" ref="a736c8ddabe690124fb1ef7f7b29b1b1b" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_range</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bbfda4142999c5c7b44b0a23332cc23"></a><!-- doxytag: member="USocket::str_close" ref="a7bbfda4142999c5c7b44b0a23332cc23" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_close</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ad459db929ba5172d7b2752a676be7"></a><!-- doxytag: member="USocket::str_cookie" ref="a79ad459db929ba5172d7b2752a676be7" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_cookie</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92801a1f91b39f0ec417698f66fcafb0"></a><!-- doxytag: member="USocket::str_setcookie" ref="a92801a1f91b39f0ec417698f66fcafb0" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_setcookie</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e30f6f332e708d608bddfc4923e66d8"></a><!-- doxytag: member="USocket::str_starttls" ref="a2e30f6f332e708d608bddfc4923e66d8" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_starttls</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fdd111b798592ae6029ab1c399b2c15"></a><!-- doxytag: member="USocket::str_location" ref="a1fdd111b798592ae6029ab1c399b2c15" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_location</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fc5e6a31da81e0c920a1d9f2633a8fe"></a><!-- doxytag: member="USocket::str_connection" ref="a7fc5e6a31da81e0c920a1d9f2633a8fe" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_connection</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d178436e07f952c28c301eef44b1820"></a><!-- doxytag: member="USocket::str_user_agent" ref="a7d178436e07f952c28c301eef44b1820" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_user_agent</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47e12c0ca11b6720fdec711a0babe327"></a><!-- doxytag: member="USocket::str_authorization" ref="a47e12c0ca11b6720fdec711a0babe327" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_authorization</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afff51a96bc87590eefe6d5255b6925f1"></a><!-- doxytag: member="USocket::str_content_type" ref="afff51a96bc87590eefe6d5255b6925f1" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_content_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7ee0dee663d7168864e553f3fdf80ec"></a><!-- doxytag: member="USocket::str_content_length" ref="ae7ee0dee663d7168864e553f3fdf80ec" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_content_length</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc2ab3eb83e592775cea790db0d78c66"></a><!-- doxytag: member="USocket::str_content_disposition" ref="acc2ab3eb83e592775cea790db0d78c66" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_content_disposition</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eefc1845040cdbf17f789410736b145"></a><!-- doxytag: member="USocket::str_accept_language" ref="a4eefc1845040cdbf17f789410736b145" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_accept_language</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a281cd5139d510ebb93a6af6f2802ee7c"></a><!-- doxytag: member="USocket::str_accept_encoding" ref="a281cd5139d510ebb93a6af6f2802ee7c" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_accept_encoding</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29a43ca4bee90a7b1d621dba111c8441"></a><!-- doxytag: member="USocket::str_if_range" ref="a29a43ca4bee90a7b1d621dba111c8441" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_if_range</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30eb94bff6c4bb080d7e024acc0b70c8"></a><!-- doxytag: member="USocket::str_if_none_match" ref="a30eb94bff6c4bb080d7e024acc0b70c8" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_if_none_match</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4bbefd241679cdb3064266ade499125"></a><!-- doxytag: member="USocket::str_if_modified_since" ref="ac4bbefd241679cdb3064266ade499125" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_if_modified_since</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9bec95c833967a5de953f831ee6ada7"></a><!-- doxytag: member="USocket::str_if_unmodified_since" ref="aa9bec95c833967a5de953f831ee6ada7" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_if_unmodified_since</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f7485dcc343431d1f89fe01459e6275"></a><!-- doxytag: member="USocket::str_referer" ref="a6f7485dcc343431d1f89fe01459e6275" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_referer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c8ca977bd44aef23bb769ae2b13fa64"></a><!-- doxytag: member="USocket::str_X_Forwarded_For" ref="a7c8ca977bd44aef23bb769ae2b13fa64" args="" -->
static <a class="el" href="classUString.html">UString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>str_X_Forwarded_For</b></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5e5c8290c3a909550d4b61905019362"></a><!-- doxytag: member="USocket::connect" ref="aa5e5c8290c3a909550d4b61905019362" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>connect</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe9e66dcddc62768ed9055427f3c8e67"></a><!-- doxytag: member="USocket::setRemote" ref="afe9e66dcddc62768ed9055427f3c8e67" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setRemote</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac64e11044d2c0fca020aead0f0802b54"></a><!-- doxytag: member="USocket::bind" ref="ac64e11044d2c0fca020aead0f0802b54" args="(SocketAddress &amp;cLocal)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>bind</b> (<a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;cLocal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54c1ce47ad603eb07b7a62df722262ce"></a><!-- doxytag: member="USocket::setServer" ref="a54c1ce47ad603eb07b7a62df722262ce" args="(SocketAddress &amp;cLocal, int iBackLog)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>setServer</b> (<a class="el" href="classSocketAddress.html">SocketAddress</a> &amp;cLocal, int iBackLog)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a055cfb3cd29fbf42fa16a45518d6b0eb">setLocal</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77e6f25f7ca9c3d1dc9c434c6720c458"></a><!-- doxytag: member="USocket::iSockDesc" ref="a77e6f25f7ca9c3d1dc9c434c6720c458" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>iSockDesc</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88dfbbab416a869d3eee5678ff821ae1"></a><!-- doxytag: member="USocket::iState" ref="a88dfbbab416a869d3eee5678ff821ae1" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>iState</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abae92ceaf286ecfdd189544ede33e126"></a><!-- doxytag: member="USocket::iLocalPort" ref="abae92ceaf286ecfdd189544ede33e126" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>iLocalPort</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad93aa7303ca971ca43d2d30de54cbef5"></a><!-- doxytag: member="USocket::iRemotePort" ref="ad93aa7303ca971ca43d2d30de54cbef5" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>iRemotePort</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2186be0a94f109f3f870aca11dbabd29"></a><!-- doxytag: member="USocket::cLocalAddress" ref="a2186be0a94f109f3f870aca11dbabd29" args="" -->
<a class="el" href="classUIPAddress.html">UIPAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>cLocalAddress</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a110f073c09210a7a4c6453c6b8646818"></a><!-- doxytag: member="USocket::cRemoteAddress" ref="a110f073c09210a7a4c6453c6b8646818" args="" -->
<a class="el" href="classUIPAddress.html">UIPAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>cRemoteAddress</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48e3d15e2f08f3e7880f876e0fb334a5"></a><!-- doxytag: member="USocket::bIPv6Socket" ref="a48e3d15e2f08f3e7880f876e0fb334a5" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>bIPv6Socket</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe5f4fbb0d437a2087ab9a0e0f1cf31b"></a><!-- doxytag: member="USocket::bLocalSet" ref="abe5f4fbb0d437a2087ab9a0e0f1cf31b" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>bLocalSet</b></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b9e7afc46f107d441c93c000b16f4be"></a><!-- doxytag: member="USocket::req_timeout" ref="a0b9e7afc46f107d441c93c000b16f4be" args="" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>req_timeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08a2ca3e01c25d95bd07134b915a8f9c"></a><!-- doxytag: member="USocket::accept4_flags" ref="a08a2ca3e01c25d95bd07134b915a8f9c" args="" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>accept4_flags</b> = SOCK_NONBLOCK | SOCK_CLOEXEC</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1a11b119504f7bcc606abae6eba5f61"></a><!-- doxytag: member="USocket::USocketExt" ref="ae1a11b119504f7bcc606abae6eba5f61" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#ae1a11b119504f7bcc606abae6eba5f61">USocketExt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c329688134d78ef26be4e0559566b29"></a><!-- doxytag: member="USocket::USSHSocket" ref="a8c329688134d78ef26be4e0559566b29" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a8c329688134d78ef26be4e0559566b29">USSHSocket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a795f2e01d8e7fca4bf0efb328d05e4b9"></a><!-- doxytag: member="USocket::UTCPSocket" ref="a795f2e01d8e7fca4bf0efb328d05e4b9" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a795f2e01d8e7fca4bf0efb328d05e4b9">UTCPSocket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a632e6e1b5551f513401b6097b517b91d"></a><!-- doxytag: member="USocket::USSLSocket" ref="a632e6e1b5551f513401b6097b517b91d" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a632e6e1b5551f513401b6097b517b91d">USSLSocket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30b8ad744c686dd77ba2d02b392e3da5"></a><!-- doxytag: member="USocket::UUnixSocket" ref="a30b8ad744c686dd77ba2d02b392e3da5" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a30b8ad744c686dd77ba2d02b392e3da5">UUnixSocket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad92b5b5f28caca032edf070fa8bac1b1"></a><!-- doxytag: member="USocket::USmtpClient" ref="ad92b5b5f28caca032edf070fa8bac1b1" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#ad92b5b5f28caca032edf070fa8bac1b1">USmtpClient</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7b7f088081c99756e08a0eea927b47f"></a><!-- doxytag: member="USocket::UImapClient" ref="ac7b7f088081c99756e08a0eea927b47f" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#ac7b7f088081c99756e08a0eea927b47f">UImapClient</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dc81d2ae3e20a25f294f3fb62e84327"></a><!-- doxytag: member="USocket::UPop3Client" ref="a2dc81d2ae3e20a25f294f3fb62e84327" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a2dc81d2ae3e20a25f294f3fb62e84327">UPop3Client</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b774e0e0aa74bd82c34de016bab8dce"></a><!-- doxytag: member="USocket::UServer_Base" ref="a3b774e0e0aa74bd82c34de016bab8dce" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a3b774e0e0aa74bd82c34de016bab8dce">UServer_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83e46667f7e5b84a34d23bdb1b4cc818"></a><!-- doxytag: member="USocket::USSLFtpClient" ref="a83e46667f7e5b84a34d23bdb1b4cc818" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a83e46667f7e5b84a34d23bdb1b4cc818">USSLFtpClient</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a519b46131851a8bbd5008ac562f037a8"></a><!-- doxytag: member="USocket::UClientImage_Base" ref="a519b46131851a8bbd5008ac562f037a8" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a519b46131851a8bbd5008ac562f037a8">UClientImage_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbda4add37917857a6a5126c72ce234"></a><!-- doxytag: member="USocket::UServer" ref="a3dbda4add37917857a6a5126c72ce234" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUSocket.html#a3dbda4add37917857a6a5126c72ce234">UServer</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>basic IP socket functionality </p>
<p>This class is used to provide basic IP socket functionality within a C++ class environment. The socket descriptor is stored as a member variable within the socket class. The member methods are simple wrappers to the standard socket library function calls except they use class <a class="el" href="classUIPAddress.html">UIPAddress</a> instances and port numbers rather than sockaddr structures </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afe635340565fa7eba1e7139955d63532"></a><!-- doxytag: member="USocket::accept" ref="afe635340565fa7eba1e7139955d63532" args="(USocket *pcConnection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUSocket.html">USocket</a> *&nbsp;</td>
          <td class="paramname"> <em>pcConnection</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept a pending connection, the <a class="el" href="classUSocket.html" title="basic IP socket functionality">USocket</a> pointed to by the provided parameter is modified to refer to the newly connected socket. The remote IP Address and port number are also returned </p>

<p>Reimplemented in <a class="el" href="classUSSLSocket.html#ad193ec26179fee25a85e4648cdd4a3e3">USSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="ab2db1524c94b038a4eeace5e272d1e15"></a><!-- doxytag: member="USocket::acceptClient" ref="ab2db1524c94b038a4eeace5e272d1e15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classUSocket.html">USocket</a>* USocket::acceptClient </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to accept a new connection on the server socket. Further communications on the newly connected socket are made via the newly created <a class="el" href="classUSocket.html" title="basic IP socket functionality">USocket</a> instance of which a pointer is returned when the connection is accepted. We create a <a class="el" href="classUSocket.html" title="basic IP socket functionality">USocket</a> instance and pass this to the base class <a class="el" href="classUSocket.html#afe635340565fa7eba1e7139955d63532">accept()</a> method to accept the pending connection on this <a class="el" href="classUSocket.html" title="basic IP socket functionality">USocket</a> instance </p>

<p>Reimplemented in <a class="el" href="classUTCPSocket.html#a2f62fc69e757b38b1dad2d13eb38d9fb">UTCPSocket</a>, <a class="el" href="classUUnixSocket.html#a1f2637568afbe1514e74d3e5357877f0">UUnixSocket</a>, and <a class="el" href="classUSSLSocket.html#ab6601bf1976add465a5a5f012cf9781e">USSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="abb900b23d64b5fb858d9ac190c917e78"></a><!-- doxytag: member="USocket::bind" ref="abb900b23d64b5fb858d9ac190c917e78" args="(int iLocalPort=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::bind </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iLocalPort</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The method is called with a local IP address and port number to bind the socket to. A default port number of zero is a wildcard and lets the OS choose the port number </p>

</div>
</div>
<a class="anchor" id="a2c487b569842c6524738fc03080c4dd0"></a><!-- doxytag: member="USocket::checkErrno" ref="a2c487b569842c6524738fc03080c4dd0" args="(int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USocket::checkErrno </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called after read block of data of remote connection </p>

</div>
</div>
<a class="anchor" id="aeeedd9dd467a3cc2e8641142808bdefa"></a><!-- doxytag: member="USocket::checkIO" ref="aeeedd9dd467a3cc2e8641142808bdefa" args="(int iBytesTransferred, int iMaxBytesTransfer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::checkIO </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iBytesTransferred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iMaxBytesTransfer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called after send block of data to remote connection </p>

</div>
</div>
<a class="anchor" id="ab998bf35a2ab65e85c13c99a933c58f1"></a><!-- doxytag: member="USocket::connectServer" ref="ab998bf35a2ab65e85c13c99a933c58f1" args="(const UString &amp;server, int iServPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::connectServer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUString.html">UString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iServPort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to connect the socket to a server TCP socket that is specified by the provided IP Address and port number. We call the connect() method to perform the connection </p>

<p>Reimplemented in <a class="el" href="classUTCPSocket.html#ad7c0417f01fb02c2bc3ff72f156302f5">UTCPSocket</a>, <a class="el" href="classUUDPSocket.html#adee8a2eeeed5b83778ae526109011165">UUDPSocket</a>, <a class="el" href="classUUnixSocket.html#a838f30157d3d2310183925eec4cad101">UUnixSocket</a>, <a class="el" href="classUSSHSocket.html#a1ccf197cfb553dc766cb9b934b66b958">USSHSocket</a>, and <a class="el" href="classUSSLSocket.html#a1b5266042cfe25954c792612f46b7d80">USSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a71bc5eac4f1b8237ffce461020d4c5f8"></a><!-- doxytag: member="USocket::connectServer" ref="a71bc5eac4f1b8237ffce461020d4c5f8" args="(const UIPAddress &amp;cAddr, int iServPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::connectServer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iServPort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect the socket to the specified server IP Address and port number </p>

</div>
</div>
<a class="anchor" id="af94c6040ed50b9c4393097f6b6810b4e"></a><!-- doxytag: member="USocket::getBufferRCV" ref="af94c6040ed50b9c4393097f6b6810b4e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USocket::getBufferRCV </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method manage the buffer of the socket connection </p>

</div>
</div>
<a class="anchor" id="af6afbf857fd9a1875428a3002a365664"></a><!-- doxytag: member="USocket::getSockOpt" ref="af6afbf857fd9a1875428a3002a365664" args="(int iCodeLevel, int iOptionName, void *pOptionData, uint32_t &amp;iDataLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::getSockOpt </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iCodeLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iOptionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pOptionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>iDataLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The getsockopt() function is called with the provided parameters to obtain the desired value </p>

</div>
</div>
<a class="anchor" id="a1299b5bc49ffe00729a0bd6571e05cbd"></a><!-- doxytag: member="USocket::listen" ref="a1299b5bc49ffe00729a0bd6571e05cbd" args="(int iBackLog=5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USocket::listen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iBackLog</em> = <code>5</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The iBackLog parameter indicates the number of unconnected sockets that can be pending in the socket queue </p>

</div>
</div>
<a class="anchor" id="a855d29ae87d399d098829e05916220ce"></a><!-- doxytag: member="USocket::localPortNumber" ref="a855d29ae87d399d098829e05916220ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USocket::localPortNumber </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get details of the IP address and port number bound to the local socket </p>

</div>
</div>
<a class="anchor" id="a8822b76fde425ed0472e3f6faaa8e40c"></a><!-- doxytag: member="USocket::recv" ref="a8822b76fde425ed0472e3f6faaa8e40c" args="(void *pBuffer, int iBufLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int USocket::recv </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iBufLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to receive a block of data on the connected socket. The parameters signify the payload receiving buffer and its size. If the socket is not connected, then we failed on assertion, otherwise we call the <a class="el" href="classUSocket.html#a3f5c7ad5e7bc631a1615ed616f290496">recv()</a> method to receive the data, returning the number of bytes actually readden </p>

<p>Reimplemented in <a class="el" href="classUUnixSocket.html#a1a2148ab0f589576d4f06d64281a7a5d">UUnixSocket</a>, <a class="el" href="classUSSHSocket.html#a6e33a0e9339d8569fc2a4850aaedf4e6">USSHSocket</a>, and <a class="el" href="classUSSLSocket.html#a3328737002f68158e924f0f0ebf6c2bc">USSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a3f5c7ad5e7bc631a1615ed616f290496"></a><!-- doxytag: member="USocket::recv" ref="a3f5c7ad5e7bc631a1615ed616f290496" args="(int fd, void *buf, size_t len, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t USocket::recv </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to receive a block of data on the connected socket. The parameters signify the payload receiving buffer and its size. If the socket is not connected, then we failed on assertion, otherwise we call the <a class="el" href="classUSocket.html#a3f5c7ad5e7bc631a1615ed616f290496">recv()</a> system call to receive the data, returning the number of bytes actually readden </p>

</div>
</div>
<a class="anchor" id="acc370dcba9600975d1a875034db07723"></a><!-- doxytag: member="USocket::recvBinary16Bits" ref="acc370dcba9600975d1a875034db07723" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USocket::recvBinary16Bits </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to read a 16-bit binary value from the remote connection. We loop - calling <a class="el" href="classUSocket.html#a3f5c7ad5e7bc631a1615ed616f290496">recv()</a> - until the required number of bytes are read, if <a class="el" href="classUSocket.html#a3f5c7ad5e7bc631a1615ed616f290496">recv()</a> returns a smaller number of bytes due to the remaining values not yet arriving, we go back into a loop. Once the value is read into uiNetOrder, we convert it to host byte order and return the read value </p>

</div>
</div>
<a class="anchor" id="a10e830a235a8982580ef713979b93412"></a><!-- doxytag: member="USocket::recvBinary32Bits" ref="a10e830a235a8982580ef713979b93412" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USocket::recvBinary32Bits </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to read a 32-bit binary value from the remote connection. We loop - calling <a class="el" href="classUSocket.html#a3f5c7ad5e7bc631a1615ed616f290496">recv()</a> - until the required number of bytes are read, if <a class="el" href="classUSocket.html#a3f5c7ad5e7bc631a1615ed616f290496">recv()</a> returns a smaller number of bytes due to the remaining values not yet arriving, we go back into a loop. Once the value is read into uiNetOrder, we convert it to host byte order and return the read value </p>

</div>
</div>
<a class="anchor" id="ab7f67685682bd52c3ea65c97d377f4a0"></a><!-- doxytag: member="USocket::recvFrom" ref="ab7f67685682bd52c3ea65c97d377f4a0" args="(void *pBuffer, int iBufLength, uint32_t uiFlags, UIPAddress &amp;cSourceIP, int &amp;iSourcePortNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USocket::recvFrom </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iBufLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>uiFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cSourceIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>iSourcePortNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The recvfrom() function is called with the proper parameters, params is placed for obtaining the source address information. The number of bytes read is returned </p>

</div>
</div>
<a class="anchor" id="a3f4f19c9fede9968e6977d96d97bd033"></a><!-- doxytag: member="USocket::remotePortNumber" ref="a3f4f19c9fede9968e6977d96d97bd033" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USocket::remotePortNumber </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get details of the IP address and port number bound to the remote socket </p>

</div>
</div>
<a class="anchor" id="af0b6a659f6f9caaccf0b0694bd33002b"></a><!-- doxytag: member="USocket::send" ref="af0b6a659f6f9caaccf0b0694bd33002b" args="(const void *pPayload, int iPayloadLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USocket::send </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pPayload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iPayloadLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to send a block of data to the remote connection. The parameters signify the Data Payload and its size. If the socket is not connected, then we failed on assertion, otherwise we call the <a class="el" href="classUSocket.html#af0b6a659f6f9caaccf0b0694bd33002b">send()</a> method to send the data, returning the number of bytes actually sent </p>

<p>Reimplemented in <a class="el" href="classUUnixSocket.html#aef0e816a44155a85a2b9d31fbb61e99e">UUnixSocket</a>, <a class="el" href="classUSSHSocket.html#ad92e04001609c65db030c5b9512609fb">USSHSocket</a>, and <a class="el" href="classUSSLSocket.html#a62f67a3914309051da7bbc5aae9c810b">USSLSocket</a>.</p>

</div>
</div>
<a class="anchor" id="afe35fa4e9376b03f0ffa96cc1cad6826"></a><!-- doxytag: member="USocket::sendBinary16Bits" ref="afe35fa4e9376b03f0ffa96cc1cad6826" args="(int iData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::sendBinary16Bits </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iData</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to send a 16-bit binary value to the remote connection. We convert the parameter to network byte order and call the <a class="el" href="classUSocket.html#af0b6a659f6f9caaccf0b0694bd33002b">send()</a> method to send it. If two bytes are not sent (the returned value is not two), return false </p>

</div>
</div>
<a class="anchor" id="ab2d74ccb56a5b06593a0a845e205af38"></a><!-- doxytag: member="USocket::sendBinary32Bits" ref="ab2d74ccb56a5b06593a0a845e205af38" args="(uint32_t lData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::sendBinary32Bits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lData</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is called to send a 32-bit binary value to the remote connection. We convert the parameter to network byte order and call the <a class="el" href="classUSocket.html#af0b6a659f6f9caaccf0b0694bd33002b">send()</a> method to send it. If four bytes are not sent (the returned value is not four), return false </p>

</div>
</div>
<a class="anchor" id="aa6ec9c594a61e961372ef4718e10ba2b"></a><!-- doxytag: member="USocket::sendTo" ref="aa6ec9c594a61e961372ef4718e10ba2b" args="(void *pPayload, int iPayloadLength, uint32_t uiFlags, UIPAddress &amp;cDestinationIP, int iDestinationPortNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USocket::sendTo </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pPayload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iPayloadLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>uiFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUIPAddress.html">UIPAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cDestinationIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iDestinationPortNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The socket transmits the data to the remote socket. </p>

</div>
</div>
<a class="anchor" id="a055cfb3cd29fbf42fa16a45518d6b0eb"></a><!-- doxytag: member="USocket::setLocal" ref="a055cfb3cd29fbf42fa16a45518d6b0eb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USocket::setLocal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This protected method is called by inherited classes when the local socket address is valid. It sets the bLocalSet flag, obtains details of the local address and stores them in the internal member variables </p>

</div>
</div>
<a class="anchor" id="a222bc630111a7fcf21a3ae519c51ff90"></a><!-- doxytag: member="USocket::setServer" ref="a222bc630111a7fcf21a3ae519c51ff90" args="(int port, int iBackLog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::setServer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iBackLog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The default local port number is automatically allocated, the default back logged queue length is 5. We then try to bind the <a class="el" href="classUSocket.html" title="basic IP socket functionality">USocket</a> to the specified port number and any local IP Address using the <a class="el" href="classUSocket.html#abb900b23d64b5fb858d9ac190c917e78">bind()</a> method. Following this, we call the <a class="el" href="classUSocket.html#a1299b5bc49ffe00729a0bd6571e05cbd">listen()</a> method to cause the socket to begin listening for new connections </p>

<p>Reimplemented in <a class="el" href="classUTCPSocket.html#a19737363f7b9bd4b1a6cbc1dcc3070b1">UTCPSocket</a>, <a class="el" href="classUUDPSocket.html#a3551d40dc223a0ab46a95287d2129b73">UUDPSocket</a>, and <a class="el" href="classUUnixSocket.html#a577d4d134f1b7afda49402da59745792">UUnixSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a59e0688b094fdd5ab29706f3074cd5c0"></a><!-- doxytag: member="USocket::setSockOpt" ref="a59e0688b094fdd5ab29706f3074cd5c0" args="(int iCodeLevel, int iOptionName, const void *pOptionData, uint32_t iDataLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::setSockOpt </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iCodeLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iOptionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pOptionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>iDataLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The setsockopt() function is called with the provided parameters to obtain the desired value </p>

</div>
</div>
<a class="anchor" id="a833a54ea53ae6e054029659733780b0e"></a><!-- doxytag: member="USocket::setTcpCork" ref="a833a54ea53ae6e054029659733780b0e" args="(uint32_t corked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USocket::setTcpCork </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>corked</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stick a TCP cork in the socket. It's not clear that this will help performance, but it might.</p>
<p>TCP_CORK: If set, don't send out partial frames. All queued partial frames are sent when the <a class="el" href="structoption.html">option</a> is cleared again. This is useful for prepending headers before calling sendfile(), or for throughput optimization. As currently implemented, there is a 200 millisecond ceiling on the time for which output is corked by TCP_CORK. If this ceiling is reached, then queued data is automatically transmitted.</p>
<p>This is a no-op if we don't think this platform has corks. </p>

</div>
</div>
<a class="anchor" id="ac5ac3939478953bdef244223e38c7e12"></a><!-- doxytag: member="USocket::setTcpDeferAccept" ref="ac5ac3939478953bdef244223e38c7e12" args="(uint32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USocket::setTcpDeferAccept </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ask for the server not to be awakened until some data has arrived on the socket. Takes an integer value (seconds), this can bound the maximum number of attempts TCP will make to complete the connection. This works for RPC protocol because the client sends a request immediately after connection without waiting for anything from the server. </p>

</div>
</div>
<a class="anchor" id="a21d81dc932813d3728551db0326dc91a"></a><!-- doxytag: member="USocket::setTimeoutRCV" ref="a21d81dc932813d3728551db0326dc91a" args="(uint32_t timeoutMS=U_TIMEOUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USocket::setTimeoutRCV </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeoutMS</em> = <code>U_TIMEOUT</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables/disables the <code>SO_TIMEOUT</code> pseudo <a class="el" href="structoption.html">option</a></p>
<p><code>SO_TIMEOUT</code> is not one of the options defined for Berkeley sockets, but was actually introduced as part of the Java API. For client sockets it has the same meaning as the <code>SO_RCVTIMEO</code> <a class="el" href="structoption.html">option</a>, which specifies the maximum number of milliseconds that a blocking <code>read()</code> call will wait for data to arrive on the socket. Timeouts only have effect for system calls that perform socket I/O (e.g., read(2), recvmsg(2), send(2), sendmsg(2));</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeoutMS</em>&nbsp;</td><td>the specified timeout value, in milliseconds. A zero value indicates no timeout, i.e. an infinite wait</td></tr>
  </table>
  </dd>
</dl>
<p>Enables/disables the <code>SO_TIMEOUT</code> pseudo <a class="el" href="structoption.html">option</a>. <code>SO_TIMEOUT</code> is not one of the options defined for Berkeley sockets, but was actually introduced as part of the Java API. For client sockets it has the same meaning as the <code>SO_RCVTIMEO</code> <a class="el" href="structoption.html">option</a>, which specifies the maximum number of milliseconds that a blocking <code>read()</code> call will wait for data to arrive on the socket.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeoutMS</em>&nbsp;</td><td>the specified timeout value, in milliseconds. A value of zero indicates no timeout, i.e. an infinite wait. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb5a12d0fcf3901ee70fed2077399fbc"></a><!-- doxytag: member="USocket::socket" ref="acb5a12d0fcf3901ee70fed2077399fbc" args="(int domain, int type, int protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int USocket::socket </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="classUSocket.html#acb5a12d0fcf3901ee70fed2077399fbc">socket()</a> function is called to create the socket of the specified type. The parameters indicate whether the socket will use IPv6 or IPv4 and the type of socket (the default being SOCK_STREAM or TCP). The returned descriptor is stored in iSockDesc </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ulib/net/<a class="el" href="socket_8h_source.html">socket.h</a></li>
<li>src/ulib/net/socket.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat Jan 23 17:17:38 2010 for ULib C++ Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
